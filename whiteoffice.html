<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Office Cubicles | Fixed Chair Orientation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a2a6c, #2c3e50, #1a2a6c);
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        #logo {
            font-size: 24px;
            font-weight: 700;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #logo::before {
            content: "üöÄ";
        }
        
        #container {
            width: 100%;
            height: calc(100vh - 70px);
            position: relative;
            overflow: hidden;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(79, 195, 247, 0.5);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(79, 195, 247, 0.3);
            min-width: 400px;
        }
        
        #loading .progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        #loading .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #1a2a6c, #4fc3f7);
            width: 0%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 300px;
            transition: opacity 0.3s ease;
        }
        
        #controls h2 {
            margin-bottom: 12px;
            color: #4fc3f7;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #controls h2 i {
            font-size: 20px;
        }
        
        #controls div {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        
        #controls .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 3px 8px;
            margin: 0 5px;
            min-width: 30px;
            text-align: center;
            font-weight: bold;
        }
        
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 300px;
            opacity: 0.9;
            transition: opacity 0.3s ease;
        }
        
        #info-panel h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #interaction-notice {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(79, 195, 247, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(79, 195, 247, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        canvas {
            display: block;
            outline: none;
        }
        
        #toggle-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 100;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #toggle-ui:hover {
            background: rgba(79, 195, 247, 0.3);
            transform: scale(1.05);
        }
        
        #time-display {
            position: absolute;
            top: 20px;
            right: 80px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 30px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(79, 195, 247, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(79, 195, 247, 0); }
            100% { box-shadow: 0 0 0 0 rgba(79, 195, 247, 0); }
        }
        
        #cubicle-controls {
            position: absolute;
            top: 20px;
            right: 150px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 30px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
            transition: opacity 0.3s ease;
        }
        
        #cubicle-controls button {
            background: rgba(79, 195, 247, 0.3);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        
        #cubicle-controls button:hover {
            background: rgba(79, 195, 247, 0.5);
            transform: scale(1.05);
        }
        
        #status-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 30px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4fc3f7;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.7);
        }
        
        #notification {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(46, 204, 113, 0.2);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(46, 204, 113, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .hidden {
            opacity: 0 !important;
            pointer-events: none;
        }
        
        #fix-chairs-btn {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(79, 195, 247, 0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 30px;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        #fix-chairs-btn:hover {
            background: rgba(46, 204, 113, 0.7);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="logo">VIRTUAL OFFICE CUBICLES</div>
        <div id="time-display">Loading...</div>
    </div>
    
    <div id="container">
        <div id="loading">
            <h2>Initializing Virtual Office</h2>
            <p>Setting up cubicles and workstations...</p>
            <div class="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <p id="progress-text">0%</p>
        </div>
        
        <div id="controls">
            <h2>üöÄ Controls</h2>
            <div><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> Move around</div>
            <div>Mouse - Look around</div>
            <div><span class="key">Space</span> Move up</div>
            <div><span class="key">Shift</span> Move down</div>
            <div>Mouse Wheel - Zoom in/out</div>
            <div><span class="key">R</span> Reset position</div>
            <div><span class="key">F</span> Toggle flashlight</div>
            <div><span class="key">C</span> Toggle day/night</div>
            <div><span class="key">E</span> Interact with objects</div>
        </div>
        
        <div id="info-panel">
            <h3>üí° Cubicle Features</h3>
            <p>Each cubicle includes:</p>
            <ul style="margin-left: 20px; margin-top: 8px;">
                <li>Professional work desk</li>
                <li>Ergonomic adjustable chair</li>
                <li>Computer with dual monitors</li>
                <li>Storage cabinets</li>
                <li>Personal lighting</li>
            </ul>
        </div>
        
        <div id="interaction-notice">Press E to interact</div>
        
        <div id="cubicle-controls">
            <button id="toggle-doors">Toggle Doors</button>
            <button id="toggle-lights">Toggle Lights</button>
        </div>
        
        <div id="status-bar">
            <div id="status-indicator"></div>
            <span>Connected to Virtual Office</span>
        </div>
        
        <div id="notification">Table and chairs orientation fixed!</div>
        
        <button id="toggle-ui" title="Toggle UI">üëÅÔ∏è</button>
        
        <button id="fix-chairs-btn">ü™ë Fix Chair Positions</button>
    </div>

    <script>
        // Update time display
        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const dateString = now.toLocaleDateString([], {weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'});
            document.getElementById('time-display').innerHTML = `${dateString} | ${timeString}`;
        }
        
        // Initialize scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
        
        // Create camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Variables
        const clock = new THREE.Clock();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let flashlightOn = false;
        let dayMode = true;
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let pitch = 0;
        let yaw = 0;
        let interactableObjects = [];
        let currentInteractable = null;
        let officeLights = [];
        let cubicleLights = [];
        let cubicleDoors = [];
        let chairs = [];
        let desks = [];
        
        // Velocity and direction
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Create a skybox
        function createSkybox() {
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            
            // Create a gradient for the sky
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a2a6c');
            gradient.addColorStop(0.5, '#2c3e50');
            gradient.addColorStop(1, '#1a2a6c');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const texture = new THREE.CanvasTexture(canvas);
            const skyMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }
        
        // Create lighting
        function createLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(10, 20, 5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            scene.add(sunLight);
            
            // Create a flashlight (will be attached to camera)
            const flashlight = new THREE.SpotLight(0xffffff, 1.5, 30, Math.PI / 6, 0.5);
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            camera.add(flashlight);
            camera.add(flashlight.target);
            
            return flashlight;
        }
        
        // Create materials with textures
        function createMaterials() {
            const textureLoader = new THREE.TextureLoader();
            
            // Create a simple checker texture for the floor
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#888888';
            context.fillRect(0, 0, 128, 128);
            context.fillStyle = '#aaaaaa';
            context.fillRect(0, 0, 64, 64);
            context.fillRect(64, 64, 64, 64);
            
            const floorTexture = new THREE.CanvasTexture(canvas);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(10, 10);
            
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: floorTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Wall material
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0f0f0,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Glass material
            const glassMaterial = new THREE.MeshStandardMaterial({
                color: 0x90c9e6,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.9
            });
            
            // Desk material (wood)
            const woodTexture = textureLoader.load('https://threejs.org/examples/textures/wood/wood_diffuse.jpg');
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(4, 1);
            
            const deskMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Chair material
            const chairMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Screen material
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                emissive: 0x111111,
                roughness: 0.1,
                metalness: 0.9
            });
            
            // Plant material
            const plantMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x27ae60,
                roughness: 0.9,
                metalness: 0
            });
            
            return {
                floorMaterial,
                wallMaterial,
                glassMaterial,
                deskMaterial,
                chairMaterial,
                screenMaterial,
                plantMaterial
            };
        }
        
        // Create floor
        function createFloor(material) {
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floor = new THREE.Mesh(floorGeometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            return floor;
        }
        
        // Create walls
        function createWall(width, height, position, rotation = 0) {
            const wallGeometry = new THREE.PlaneGeometry(width, height);
            const wall = new THREE.Mesh(wallGeometry, materials.wallMaterial);
            wall.position.copy(position);
            wall.rotation.y = rotation;
            wall.receiveShadow = true;
            scene.add(wall);
            return wall;
        }
        
        // Create desk
        function createDesk(position, rotation) {
            const deskGroup = new THREE.Group();
            
            // Desk surface
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.2, 2),
                materials.deskMaterial
            );
            deskTop.position.y = 1.5;
            deskTop.castShadow = true;
            deskGroup.add(deskTop);
            
            // Desk legs
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8),
                    materials.deskMaterial
                );
                leg.position.x = (i % 2) * 3.8 - 1.9;
                leg.position.z = Math.floor(i / 2) * 1.8 - 0.9;
                leg.position.y = 0.75;
                leg.castShadow = true;
                deskGroup.add(leg);
            }
            
            // Computer monitor (dual setup)
            for (let i = -1; i <= 1; i += 2) {
                const monitor = new THREE.Mesh(
                    new THREE.BoxGeometry(1.0, 0.6, 0.1),
                    materials.screenMaterial
                );
                monitor.position.set(i * 0.6, 2.1, -0.5);
                monitor.castShadow = true;
                deskGroup.add(monitor);
                
                // Monitor stand
                const stand = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.15, 0.3, 8),
                    materials.deskMaterial
                );
                stand.position.set(i * 0.6, 1.75, -0.5);
                stand.castShadow = true;
                deskGroup.add(stand);
                
                // Add screen texture
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Draw a fake code editor
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, 256, 256);
                
                // Draw some code
                ctx.font = '12px monospace';
                ctx.fillStyle = '#d4d4d4';
                ctx.fillText('function createCubicle() {', 10, 30);
                ctx.fillText('  const desk = new Desk();', 10, 50);
                ctx.fillText('  const chair = new Chair();', 10, 70);
                ctx.fillText('  return {desk, chair};', 10, 90);
                ctx.fillText('}', 10, 110);
                
                // Draw cursor
                ctx.fillStyle = '#569cd6';
                ctx.fillRect(75, 110, 8, 12);
                
                const screenTexture = new THREE.CanvasTexture(canvas);
                const screenMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.9, 0.5),
                    new THREE.MeshBasicMaterial({ map: screenTexture })
                );
                // FIX: Properly orient screens to face chairs
                screenMesh.position.set(i * 0.6, 2.1, -0.45);  // Position at front of monitor
                screenMesh.rotation.x = 0;  // Face forward (positive Z)
                deskGroup.add(screenMesh);
            }
            
            // Desk drawers
            const drawer = new THREE.Mesh(
                new THREE.BoxGeometry(3.0, 0.5, 1.0),
                materials.deskMaterial
            );
            drawer.position.set(0, 0.75, 0.5);
            drawer.castShadow = true;
            deskGroup.add(drawer);
            
            // Drawer handles
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8),
                materials.chairMaterial
            );
            handle.rotation.z = Math.PI/2;
            handle.position.set(0, 0.75, 1.0);
            deskGroup.add(handle);
            
            deskGroup.position.copy(position);
            if (rotation !== undefined) {
                deskGroup.rotation.y = rotation;
            }
            
            // Make the screen interactive
            const monitors = deskGroup.children.filter(c => c.name === 'monitor');
            monitors.forEach(monitor => {
                monitor.userData = { interactive: true, type: 'screen' };
                interactableObjects.push(monitor);
            });
            
            // Store desk for later reference
            desks.push(deskGroup);
            
            return deskGroup;
        }
        
        // Create ergonomic chair
        function createChair(position, rotation) {
            const chairGroup = new THREE.Group();
            
            // Chair base
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16),
                materials.chairMaterial
            );
            base.position.y = 0.05;
            base.castShadow = true;
            chairGroup.add(base);
            
            // Central column
            const column = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 1, 8),
                materials.chairMaterial
            );
            column.position.y = 0.55;
            column.castShadow = true;
            chairGroup.add(column);
            
            // Chair seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.2, 1.2),
                materials.chairMaterial
            );
            seat.position.y = 1.1;
            seat.castShadow = true;
            chairGroup.add(seat);
            
            // Chair back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(1.0, 1.2, 0.1),
                materials.chairMaterial
            );
            back.position.set(0, 1.65, -0.5);
            back.rotation.x = -Math.PI/10;
            back.castShadow = true;
            chairGroup.add(back);
            
            // Armrests
            for (let i = -1; i <= 1; i += 2) {
                const armrest = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.8),
                    materials.chairMaterial
                );
                armrest.position.set(i * 0.55, 1.25, -0.1);
                armrest.castShadow = true;
                chairGroup.add(armrest);
            }
            
            // Chair wheels
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const radius = 0.3;
                const wheel = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    materials.chairMaterial
                );
                wheel.position.x = Math.cos(angle) * radius;
                wheel.position.z = Math.sin(angle) * radius;
                wheel.position.y = 0.05;
                chairGroup.add(wheel);
            }
            
            // FIX: Remove the +0.5 adjustment to prevent floating effect
            chairGroup.position.copy(position);
            
            if (rotation !== undefined) {
                chairGroup.rotation.y = rotation;
            }
            
            // Make the chair interactive
            seat.userData = { interactive: true, type: 'chair' };
            interactableObjects.push(seat);
            
            // Store chair for later reference
            chairs.push(chairGroup);
            
            return chairGroup;
        }
        
        // Create cubicle walls
        function createCubicle(position, size) {
            const cubicleGroup = new THREE.Group();
            
            // Dimensions
            const width = size;
            const depth = size;
            const height = 2.5;
            const thickness = 0.1;
            
            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, thickness),
                materials.wallMaterial
            );
            backWall.position.set(0, height/2, -depth/2);
            cubicleGroup.add(backWall);
            
            // Side walls
            const sideWall = new THREE.Mesh(
                new THREE.BoxGeometry(thickness, height, depth),
                materials.wallMaterial
            );
            // Left wall
            const leftWall = sideWall.clone();
            leftWall.position.set(-width/2, height/2, 0);
            cubicleGroup.add(leftWall);
            
            // Right wall
            const rightWall = sideWall.clone();
            rightWall.position.set(width/2, height/2, 0);
            cubicleGroup.add(rightWall);
            
            // Glass partition at front
            const glassPartition = new THREE.Mesh(
                new THREE.BoxGeometry(width * 0.8, height * 0.6, thickness),
                materials.glassMaterial
            );
            glassPartition.position.set(0, height * 0.3, depth/2 - 0.1);
            cubicleGroup.add(glassPartition);
            
            // Door
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(width * 0.2, height * 0.9, thickness),
                materials.wallMaterial
            );
            door.position.set(width * 0.3, height * 0.45, depth/2 - 0.1);
            door.userData = { open: false, pivot: depth/2 - 0.1, initialPos: new THREE.Vector3(width * 0.3, height * 0.45, depth/2 - 0.1) };
            cubicleGroup.add(door);
            cubicleDoors.push(door);
            
            // Cubicle light
            const light = new THREE.PointLight(0xffffff, 0.8, 10);
            light.position.set(0, height - 0.2, 0);
            light.castShadow = true;
            cubicleGroup.add(light);
            cubicleLights.push(light);
            
            // Light fixture
            const fixture = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16),
                new THREE.MeshStandardMaterial({ color: 0xeeeeee })
            );
            fixture.position.set(0, height - 0.25, 0);
            fixture.rotation.x = Math.PI/2;
            cubicleGroup.add(fixture);
            
            cubicleGroup.position.copy(position);
            scene.add(cubicleGroup);
            
            return cubicleGroup;
        }
        
        // Create office furniture
        function createFurniture() {
            // Create cubicles
            const cubicles = [
                { position: new THREE.Vector3(-10, 0, -10), rotation: 0 },
                { position: new THREE.Vector3(10, 0, -10), rotation: 0 },
                { position: new THREE.Vector3(-10, 0, 10), rotation: Math.PI },
                { position: new THREE.Vector3(10, 0, 10), rotation: Math.PI }
            ];
            
            cubicles.forEach(cubicle => {
                const cubicleObj = createCubicle(cubicle.position, 6);
                cubicleObj.rotation.y = cubicle.rotation;
                
                // Calculate positions for desk and chair relative to cubicle
                const deskPos = new THREE.Vector3();
                // FIX: Move chairs back by 0.3 units for better spacing
                const chairPos = new THREE.Vector3(0, 0, 1.8); // Changed from 1.5 to 1.8
                
                // Apply cubicle rotation to positions
                deskPos.applyAxisAngle(new THREE.Vector3(0,1,0), cubicle.rotation);
                chairPos.applyAxisAngle(new THREE.Vector3(0,1,0), cubicle.rotation);
                
                // Add cubicle position
                deskPos.add(cubicle.position);
                chairPos.add(cubicle.position);
                
                // Create desk and chair with proper rotation
                const desk = createDesk(deskPos, cubicle.rotation);
                scene.add(desk);
                
                // FIXED: Calculate correct chair rotation to face the desk
                // Chair should face the opposite direction of the cubicle's forward
                const chairRotation = cubicle.rotation + Math.PI;
                const chair = createChair(chairPos, chairRotation);
                scene.add(chair);
            });
            
            // Create meeting table in center
            const tableGroup = new THREE.Group();
            
            // Table surface
            const tableTop = new THREE.Mesh(
                new THREE.CylinderGeometry(3, 3, 0.2, 32),
                materials.deskMaterial
            );
            tableTop.position.y = 1.5;
            tableTop.castShadow = true;
            tableGroup.add(tableTop);
            
            // Table stand
            const stand = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8),
                materials.deskMaterial
            );
            stand.position.y = 0.75;
            tableGroup.add(stand);
            
            tableGroup.position.set(0, 0, -5);
            scene.add(tableGroup);
            
            // Make the table interactive
            tableTop.userData = { interactive: true, type: 'table' };
            interactableObjects.push(tableTop);
            
            // Create meeting chairs around table
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * 4;
                const z = Math.sin(angle) * 4 - 5;
                
                // Calculate direction from chair to table center (0,0,-5)
                const dx = 0 - x;
                const dz = -5 - z;
                
                // Calculate the angle to face the table center
                const rotation = Math.atan2(dx, dz);
                const chair = createChair(new THREE.Vector3(x, 0, z), rotation);
                scene.add(chair);
            }
        }
        
        // Create decorative elements
        function createDecorations() {
            // Add some ceiling lights
            for (let i = -20; i <= 20; i += 10) {
                for (let j = -20; j <= 20; j += 10) {
                    const lightFixture = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.8, 1, 0.2, 16),
                        new THREE.MeshStandardMaterial({ color: 0xeeeeee, emissive: 0x444444 })
                    );
                    lightFixture.position.set(i, 8, j);
                    lightFixture.rotation.x = Math.PI / 2;
                    scene.add(lightFixture);
                    
                    const light = new THREE.PointLight(0xffffff, 0.8, 20);
                    light.position.set(i, 7.8, j);
                    scene.add(light);
                    officeLights.push(light);
                }
            }
            
            // Add some plants
            for (let i = -22; i <= 22; i += 15) {
                for (let j = -22; j <= 22; j += 15) {
                    if (Math.abs(i) < 20 && Math.abs(j) < 20) continue;
                    
                    const pot = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.6, 0.8, 16),
                        new THREE.MeshStandardMaterial({ color: 0x795548 })
                    );
                    pot.position.set(i, 0.4, j);
                    scene.add(pot);
                    
                    const plant = new THREE.Mesh(
                        new THREE.ConeGeometry(1.2, 2.5, 8),
                        materials.plantMaterial
                    );
                    plant.position.set(i, 1.8, j);
                    scene.add(plant);
                }
            }
        }
        
        // Initialize the scene
        function initScene() {
            // Create skybox
            createSkybox();
            
            // Create materials
            const mats = createMaterials();
            materials = mats;
            
            // Create floor
            createFloor(mats.floorMaterial);
            
            // Create walls
            createWall(50, 12, new THREE.Vector3(0, 6, -25)); // Back wall
            createWall(50, 12, new THREE.Vector3(0, 6, 25), Math.PI); // Front wall
            createWall(50, 12, new THREE.Vector3(-25, 6, 0), Math.PI / 2); // Left wall
            createWall(50, 12, new THREE.Vector3(25, 6, 0), -Math.PI / 2); // Right wall
            
            // Create furniture
            createFurniture();
            
            // Create decorations
            createDecorations();
            
            // Create lights
            const flashlight = createLights();
            
            // Set initial camera position
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            return flashlight;
        }
        
        // Event listeners
        function setupEventListeners(flashlight) {
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': moveUp = true; event.preventDefault(); break;
                    case 'ShiftLeft': moveDown = true; break;
                    case 'KeyR': 
                        camera.position.set(0, 5, 15);
                        camera.lookAt(0, 0, 0);
                        pitch = 0;
                        yaw = 0;
                        break;
                    case 'KeyF':
                        flashlightOn = !flashlightOn;
                        flashlight.visible = flashlightOn;
                        break;
                    case 'KeyC':
                        dayMode = !dayMode;
                        scene.background = dayMode ? new THREE.Color(0x87CEEB) : new THREE.Color(0x111111);
                        officeLights.forEach(light => {
                            light.intensity = dayMode ? 0.8 : 1.5;
                        });
                        break;
                    case 'KeyE':
                        if (currentInteractable) {
                            interactWithObject(currentInteractable);
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'Space': moveUp = false; break;
                    case 'ShiftLeft': moveDown = false; break;
                }
            });
            
            // Mouse controls
            document.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
                document.body.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
                document.body.style.cursor = 'default';
            });
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    yaw -= deltaX * 0.005;
                    pitch -= deltaY * 0.005;
                    
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            // Mouse wheel zoom
            document.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomSpeed = 0.1;
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(camera.quaternion);
                
                if (event.deltaY > 0) {
                    // Zoom out
                    camera.position.add(direction.multiplyScalar(zoomSpeed));
                } else {
                    // Zoom in
                    camera.position.add(direction.multiplyScalar(-zoomSpeed));
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Toggle UI button
            document.getElementById('toggle-ui').addEventListener('click', () => {
                const controls = document.getElementById('controls');
                const infoPanel = document.getElementById('info-panel');
                const cubicleControls = document.getElementById('cubicle-controls');
                const fixChairsBtn = document.getElementById('fix-chairs-btn');
                
                if (controls.classList.contains('hidden')) {
                    controls.classList.remove('hidden');
                    infoPanel.classList.remove('hidden');
                    cubicleControls.classList.remove('hidden');
                    fixChairsBtn.classList.remove('hidden');
                    document.getElementById('toggle-ui').textContent = 'üëÅÔ∏è';
                } else {
                    controls.classList.add('hidden');
                    infoPanel.classList.add('hidden');
                    cubicleControls.classList.add('hidden');
                    fixChairsBtn.classList.add('hidden');
                    document.getElementById('toggle-ui').textContent = 'üëÅÔ∏è‚Äçüó®Ô∏è';
                }
            });
            
            // Toggle cubicle doors
            document.getElementById('toggle-doors').addEventListener('click', () => {
                cubicleDoors.forEach(door => {
                    door.userData.open = !door.userData.open;
                    if (door.userData.open) {
                        door.position.x = door.userData.initialPos.x + 1.5;
                    } else {
                        door.position.x = door.userData.initialPos.x;
                    }
                });
            });
            
            // Toggle cubicle lights
            document.getElementById('toggle-lights').addEventListener('click', () => {
                cubicleLights.forEach(light => {
                    light.visible = !light.visible;
                });
            });
            
            // Fix chairs button
            document.getElementById('fix-chairs-btn').addEventListener('click', () => {
                repositionChairs();
                
                // Show notification
                const notification = document.getElementById('notification');
                notification.textContent = "Chairs repositioned to face desks!";
                notification.style.backgroundColor = 'rgba(46, 204, 113, 0.2)';
                notification.style.borderColor = 'rgba(46, 204, 113, 0.3)';
                notification.style.opacity = 1;
                
                setTimeout(() => {
                    notification.style.opacity = 0;
                }, 3000);
            });
        }
        
        // Handle object interaction
        function interactWithObject(object) {
            if (!object.userData) return;
            
            const interactionNotice = document.getElementById('interaction-notice');
            
            switch (object.userData.type) {
                case 'screen':
                    interactionNotice.textContent = "Computer: Accessing workstation...";
                    interactionNotice.style.backgroundColor = 'rgba(79, 195, 247, 0.3)';
                    break;
                case 'chair':
                    interactionNotice.textContent = "Chair: Adjusted to ergonomic position";
                    interactionNotice.style.backgroundColor = 'rgba(46, 204, 113, 0.3)';
                    
                    // Animate chair adjustment
                    const chair = object.parent;
                    if (chair) {
                        const targetY = chair.position.y + 0.2;
                        const duration = 1000;
                        const startTime = Date.now();
                        
                        function adjustChair() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const easeProgress = 1 - Math.pow(1 - progress, 3);
                            
                            chair.position.y = object.position.y + easeProgress * 0.2;
                            
                            if (progress < 1) {
                                requestAnimationFrame(adjustChair);
                            }
                        }
                        
                        adjustChair();
                    }
                    break;
                case 'table':
                    interactionNotice.textContent = "Meeting table: Ready for collaboration";
                    interactionNotice.style.backgroundColor = 'rgba(155, 89, 182, 0.3)';
                    break;
            }
            
            interactionNotice.style.opacity = 1;
            setTimeout(() => {
                interactionNotice.style.opacity = 0;
            }, 2000);
        }
        
        // Check for interactable objects
        function checkForInteractables() {
            currentInteractable = null;
            const interactionNotice = document.getElementById('interaction-notice');
            
            // Create raycaster from camera
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Find closest interactable object
            const intersects = raycaster.intersectObjects(interactableObjects);
            
            if (intersects.length > 0 && intersects[0].distance < 5) {
                currentInteractable = intersects[0].object;
                interactionNotice.textContent = "Press E to interact";
                interactionNotice.style.opacity = 1;
            } else {
                interactionNotice.style.opacity = 0;
            }
        }
        
        // Reposition chairs to face desks
        function repositionChairs() {
            chairs.forEach(chair => {
                // Find the closest desk
                let closestDesk = null;
                let minDistance = Infinity;
                
                desks.forEach(desk => {
                    const distance = chair.position.distanceTo(desk.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestDesk = desk;
                    }
                });
                
                if (closestDesk) {
                    // Calculate direction from chair to desk
                    const dx = closestDesk.position.x - chair.position.x;
                    const dz = closestDesk.position.z - chair.position.z;
                    
                    // Calculate the rotation to face the desk
                    const rotation = Math.atan2(dx, dz);
                    
                    // Animate chair rotation
                    const startRotation = chair.rotation.y;
                    const targetRotation = rotation;
                    const duration = 1000;
                    const startTime = Date.now();
                    
                    function rotateChair() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                        
                        chair.rotation.y = startRotation + (targetRotation - startRotation) * easeProgress;
                        
                        if (progress < 1) {
                            requestAnimationFrame(rotateChair);
                        }
                    }
                    
                    rotateChair();
                }
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update time
            updateTime();
            
            // Update camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            // Movement
            const delta = clock.getDelta();
            const speed = 5 * delta;
            velocity.x = 0;
            velocity.z = 0;
            velocity.y = 0;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.y = Number(moveUp) - Number(moveDown);
            direction.normalize();
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed;
            if (moveUp || moveDown) velocity.y += direction.y * speed;
            
            // Apply camera rotation to movement
            const quaternion = new THREE.Quaternion().setFromEuler(camera.rotation);
            velocity.applyQuaternion(quaternion);
            
            camera.position.add(velocity);
            
            // Keep camera above ground
            camera.position.y = Math.max(2, camera.position.y);
            
            // Check for interactable objects
            checkForInteractables();
            
            renderer.render(scene, camera);
        }
        
        // Simulate loading progress
        function simulateLoading() {
            let progress = 0;
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            const interval = setInterval(() => {
                progress += Math.random() * 5;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                        // Show notification
                        const notification = document.getElementById('notification');
                        notification.textContent = "Office loaded! Chairs positioned correctly.";
                        notification.style.opacity = 1;
                        setTimeout(() => {
                            notification.style.opacity = 0;
                        }, 3000);
                    }, 500);
                }
                
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${Math.round(progress)}%`;
            }, 100);
        }
        
        // Main initialization
        let materials;
        const flashlight = initScene();
        setupEventListeners(flashlight);
        simulateLoading();
        animate();
    </script>
</body>
</html>
