<!DOCTYPE html>
<html>
<head>
    <title>Mobile-Optimized Autostereoscopic Engine</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .upload-area {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            background: #f8f9fa;
            border-color: #0070f3;
        }
        .upload-area.drag-over {
            background: #e3f2fd;
            border-color: #2196f3;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .control-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .preview-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .preview-box {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .preview-box h3 {
            margin: 0 0 10px 0;
            font-size: 0.9em;
            color: #666;
        }
        canvas {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        #outputCanvas {
            width: 100%;
            height: auto;
            margin: 20px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }
        input[type="file"] {
            display: none;
        }
        button {
            background: #0070f3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        button:hover {
            background: #0051b3;
        }
        button.active {
            background: #004299;
        }
        .export-panel {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .mode-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            background: #e3f2fd;
            color: #0070f3;
            font-size: 0.8em;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Mobile-Optimized Autostereoscopic Engine <span class="mode-indicator" id="modeIndicator">Desktop Mode</span></h1>
        
        <div class="upload-area" id="dropZone">
            <p>Drop image here or click to upload</p>
            <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="controls">
            <div class="control-panel">
                <h2>View Controls</h2>
                <div class="control-group">
                    <button id="toggleMode">Toggle Mobile/Desktop Mode</button>
                </div>
                <div class="control-group">
                    <label>Perspective Separation</label>
                    <input type="range" id="separation" min="1" max="100" value="30">
                </div>
                <div class="control-group">
                    <label>Animation Speed</label>
                    <input type="range" id="animSpeed" min="1" max="100" value="50">
                </div>
                <div class="control-group">
                    <label>Motion Range</label>
                    <input type="range" id="motionRange" min="1" max="100" value="70">
                </div>
            </div>

            <div class="control-panel">
                <h2>Effect Controls</h2>
                <div class="control-group">
                    <label>Barrier Width</label>
                    <input type="range" id="barrierWidth" min="1" max="20" value="4">
                </div>
                <div class="control-group">
                    <label>Barrier Opacity</label>
                    <input type="range" id="barrierOpacity" min="0" max="100" value="50">
                </div>
                <div class="control-group">
                    <label>Depth Intensity</label>
                    <input type="range" id="depthIntensity" min="0" max="100" value="50">
                </div>
            </div>
        </div>

        <canvas id="outputCanvas"></canvas>
        
        <div class="preview-container">
            <div class="preview-box">
                <h3>Left View</h3>
                <canvas id="leftPreview"></canvas>
            </div>
            <div class="preview-box">
                <h3>Right View</h3>
                <canvas id="rightPreview"></canvas>
            </div>
        </div>

        <div class="export-panel">
            <button id="exportGif">Export as GIF</button>
            <button id="startAnim">Start Animation</button>
            <button id="stopAnim">Stop Animation</button>
        </div>
    </div>

    <script>
        class OptimizedStereoscopicEngine {
    constructor() {
        this.setupDOM();
        this.setupEventListeners();
        this.isMobileMode = false;
        this.isAnimating = false;
        this.animationPhase = 0;
        this.frames = [];
        // Pre-create reusable canvases
        this.leftViewCanvas = document.createElement('canvas');
        this.rightViewCanvas = document.createElement('canvas');
        this.barrierCanvas = document.createElement('canvas');
        // Create off-screen buffer
        this.buffer = document.createElement('canvas');
        this.bufferCtx = this.buffer.getContext('2d', { alpha: false });
        // Store previous values for dirty checking
        this.previousValues = {
            barrierWidth: 0,
            barrierOpacity: 0
        };
    }

    setupDOM() {
        this.dropZone = document.getElementById('dropZone');
        this.imageInput = document.getElementById('imageInput');
        this.outputCanvas = document.getElementById('outputCanvas');
        this.leftPreview = document.getElementById('leftPreview');
        this.rightPreview = document.getElementById('rightPreview');
        // Use alpha: false for better performance when we don't need transparency
        this.ctx = this.outputCanvas.getContext('2d', { alpha: false });
        this.modeIndicator = document.getElementById('modeIndicator');
    }

    setupEventListeners() {
        // File upload handling
        this.dropZone.addEventListener('click', () => this.imageInput.click());
        this.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.dropZone.classList.add('drag-over');
        });
        this.dropZone.addEventListener('dragleave', () => {
            this.dropZone.classList.remove('drag-over');
        });
        this.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            this.dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                this.loadImage(file);
            }
        });
        this.imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) this.loadImage(file);
        });

        // Mode toggle
        document.getElementById('toggleMode').addEventListener('click', () => {
            this.isMobileMode = !this.isMobileMode;
            this.modeIndicator.textContent = this.isMobileMode ? 'Mobile Mode' : 'Desktop Mode';
            if (this.sourceImage) this.updateView();
        });

        // Animation controls
        document.getElementById('startAnim').addEventListener('click', () => this.startAnimation());
        document.getElementById('stopAnim').addEventListener('click', () => this.stopAnimation());
        document.getElementById('exportGif').addEventListener('click', () => this.exportAsGif());

        // Update on control changes using debounce for performance
        const controls = ['separation', 'animSpeed', 'motionRange', 'barrierWidth', 'barrierOpacity', 'depthIntensity'];
        controls.forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('input', this.debounce(() => {
                if (this.sourceImage) this.updateView();
            }, 16)); // Debounced to roughly match 60fps
        });
    }

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    loadImage(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.sourceImage = new Image();
            this.sourceImage.onload = () => {
                this.setupCanvases();
                this.updateView();
            };
            this.sourceImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    setupCanvases() {
        const maxWidth = 800;
        const scale = Math.min(1, maxWidth / this.sourceImage.width);
        
        const width = this.sourceImage.width * scale;
        const height = this.sourceImage.height * scale;
        
        // Set dimensions for all canvases at once
        [this.outputCanvas, this.buffer, this.leftViewCanvas, this.rightViewCanvas, this.barrierCanvas]
            .forEach(canvas => {
                canvas.width = width;
                canvas.height = height;
            });
        
        // Preview canvases are quarter size
        this.leftPreview.width = this.rightPreview.width = width / 4;
        this.leftPreview.height = this.rightPreview.height = height / 4;
    }

    createView(offset, phase = null) {
        const canvas = offset < 0 ? this.leftViewCanvas : this.rightViewCanvas;
        const ctx = canvas.getContext('2d', { alpha: false });
        
        const baseOffset = document.getElementById('separation').value;
        const depthIntensity = document.getElementById('depthIntensity').value / 100;
        const motionRange = document.getElementById('motionRange').value / 100;
        
        let dynamicOffset = offset * baseOffset / 25;
        if (phase !== null) {
            dynamicOffset *= (1 + Math.sin(phase) * motionRange);
        }

        ctx.save();
        // Use integer values for better performance
        const scale = 1 + Math.abs(dynamicOffset) / 1000;
        ctx.setTransform(
            scale,
            0,
            0,
            scale,
            -canvas.width * (scale - 1) / 2 + dynamicOffset,
            -canvas.height * (scale - 1) / 2 + Math.abs(dynamicOffset) * 0.1
        );
        
        ctx.drawImage(this.sourceImage, 0, 0, canvas.width, canvas.height);
        ctx.restore();

        return canvas;
    }

    createBarrierStrips() {
        const barrierWidth = parseInt(document.getElementById('barrierWidth').value);
        const opacity = document.getElementById('barrierOpacity').value / 100;
        
        // Only recreate barrier if parameters changed
        if (barrierWidth === this.previousValues.barrierWidth && 
            opacity === this.previousValues.barrierOpacity) {
            return this.barrierCanvas;
        }
        
        const ctx = this.barrierCanvas.getContext('2d', { alpha: true });
        ctx.clearRect(0, 0, this.barrierCanvas.width, this.barrierCanvas.height);
        
        // Draw barriers in a single path
        ctx.beginPath();
        for (let x = 0; x < this.barrierCanvas.width; x += barrierWidth * 2) {
            ctx.rect(x, 0, barrierWidth, this.barrierCanvas.height);
        }
        ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
        ctx.fill();
        
        this.previousValues.barrierWidth = barrierWidth;
        this.previousValues.barrierOpacity = opacity;
        
        return this.barrierCanvas;
    }

    updateView() {
        if (!this.sourceImage) return;

        const leftView = this.createView(-1, this.animationPhase);
        const rightView = this.createView(1, this.animationPhase);

        // Update previews using faster drawImage
        const leftCtx = this.leftPreview.getContext('2d', { alpha: false });
        const rightCtx = this.rightPreview.getContext('2d', { alpha: false });
        leftCtx.drawImage(leftView, 0, 0, this.leftPreview.width, this.leftPreview.height);
        rightCtx.drawImage(rightView, 0, 0, this.rightPreview.width, this.rightPreview.height);

        // Clear buffer once
        this.bufferCtx.clearRect(0, 0, this.buffer.width, this.buffer.height);

        if (this.isMobileMode) {
            const phase = (1 + Math.sin(this.animationPhase)) / 2;
            this.bufferCtx.globalAlpha = 1 - phase;
            this.bufferCtx.drawImage(leftView, 0, 0);
            this.bufferCtx.globalAlpha = phase;
            this.bufferCtx.drawImage(rightView, 0, 0);
            this.bufferCtx.globalAlpha = 1;
        } else {
            const barrierWidth = parseInt(document.getElementById('barrierWidth').value);
            
            // Draw strips in batches for better performance
            const batchSize = 10;
            for (let i = 0; i < this.buffer.width; i += barrierWidth * 2 * batchSize) {
                for (let j = 0; j < batchSize && i + j * barrierWidth * 2 < this.buffer.width; j++) {
                    const x = i + j * barrierWidth * 2;
                    // Draw left and right strips
                    this.bufferCtx.drawImage(leftView, 
                        x, 0, barrierWidth, this.buffer.height,
                        x, 0, barrierWidth, this.buffer.height);
                    
                    if (x + barrierWidth < this.buffer.width) {
                        this.bufferCtx.drawImage(rightView,
                            x + barrierWidth, 0, barrierWidth, this.buffer.height,
                            x + barrierWidth, 0, barrierWidth, this.buffer.height);
                    }
                }
            }

            // Apply barrier overlay
            this.bufferCtx.drawImage(this.createBarrierStrips(), 0, 0);
        }

        // Single draw operation to main canvas
        this.ctx.drawImage(this.buffer, 0, 0);
    }

    startAnimation() {
        if (this.isAnimating) return;
        this.isAnimating = true;
        this.animate();
    }

    stopAnimation() {
        this.isAnimating = false;
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
    }

    animate() {
        if (!this.isAnimating) return;

        const speed = document.getElementById('animSpeed').value / 1000;
        this.animationPhase += speed;
        
        // Use requestAnimationFrame timestamp for smoother animation
        const animate = (timestamp) => {
            if (!this.isAnimating) return;
            this.updateView();
            this.animationFrame = requestAnimationFrame(animate);
        };
        
        this.animationFrame = requestAnimationFrame(animate);
    }

    async exportAsGif() {
        if (!this.sourceImage) return;

        try {
            const frameCount = 30;
            const gif = new GIF({
                workers: 4, // Increased from 2 to 4 for faster processing
                quality: 10,
                width: this.outputCanvas.width,
                height: this.outputCanvas.height,
                workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
            });

            const wasAnimating = this.isAnimating;
            this.stopAnimation();

            // Pre-render frames to avoid GIF encoding delays
            const frames = [];
            for (let i = 0; i < frameCount; i++) {
                const phase = (i / frameCount) * Math.PI * 2;
                this.animationPhase = phase;
                this.updateView();
                frames.push(this.outputCanvas.toDataURL('image/png'));
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            // Add frames to GIF
            for (const frame of frames) {
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = frame;
                });
                gif.addFrame(img, { delay: 50 });
            }

            return new Promise((resolve, reject) => {
                gif.on('finished', (blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'stereoscopic.gif';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    if (wasAnimating) this.startAnimation();
                    resolve();
                });

                gif.render();
            });
        } catch (error) {
            console.error('Error generating GIF:', error);
            alert('Error generating GIF. Please try again.');
        }
    }
}

// Initialize the engine
const engine = new OptimizedStereoscopicEngine();
    </script>
</body>
</html>
