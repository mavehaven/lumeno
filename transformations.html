<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mathematical Transformations — Interactive 3D Atlas</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=JetBrains+Mono:wght@300;400;500&family=Crimson+Pro:ital,wght@0,300;0,400;1,300&display=swap');

  :root {
    --ink: #0a0a12;
    --paper: #f5f0e8;
    --amber: #c8922a;
    --amber-light: #e8b84b;
    --teal: #1a6b6b;
    --teal-light: #2a9d8f;
    --rose: #8b3a52;
    --slate: #2d3561;
    --grid: rgba(10,10,18,0.08);
    --grid-strong: rgba(10,10,18,0.18);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--paper);
    color: var(--ink);
    font-family: 'Crimson Pro', serif;
    font-size: 17px;
    line-height: 1.7;
    overflow-x: hidden;
  }

  /* Aged paper texture */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: 
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='400' height='400' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 9999;
    opacity: 0.5;
  }

  header {
    text-align: center;
    padding: 60px 40px 40px;
    border-bottom: 2px solid var(--ink);
    position: relative;
  }

  header::after {
    content: '';
    position: absolute;
    bottom: 4px;
    left: 0; right: 0;
    height: 1px;
    background: var(--ink);
  }

  .vol-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: var(--amber);
    margin-bottom: 16px;
  }

  h1 {
    font-family: 'Playfair Display', serif;
    font-size: clamp(2.2rem, 5vw, 4rem);
    font-weight: 700;
    line-height: 1.1;
    letter-spacing: -1px;
    margin-bottom: 12px;
  }

  h1 em {
    font-style: italic;
    color: var(--amber);
  }

  .subtitle {
    font-family: 'Crimson Pro', serif;
    font-style: italic;
    font-size: 1.2rem;
    color: #555;
    max-width: 600px;
    margin: 0 auto;
  }

  /* Navigation */
  nav {
    display: flex;
    justify-content: center;
    gap: 0;
    border-bottom: 1px solid var(--ink);
    background: var(--ink);
    overflow-x: auto;
  }

  nav button {
    background: none;
    border: none;
    color: var(--paper);
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 14px 24px;
    cursor: pointer;
    transition: all 0.25s;
    white-space: nowrap;
    border-right: 1px solid rgba(255,255,255,0.1);
    position: relative;
  }

  nav button::after {
    content: '';
    position: absolute;
    bottom: 0; left: 0; right: 0;
    height: 3px;
    background: var(--amber);
    transform: scaleX(0);
    transition: transform 0.25s;
  }

  nav button:hover::after, nav button.active::after { transform: scaleX(1); }
  nav button.active { color: var(--amber-light); }

  /* Main layout */
  .main {
    display: grid;
    grid-template-columns: 1fr 360px;
    min-height: calc(100vh - 200px);
  }

  .canvas-area {
    padding: 40px;
    border-right: 1px solid var(--grid-strong);
    position: relative;
  }

  .sidebar {
    padding: 32px 28px;
    background: rgba(10,10,18,0.03);
  }

  /* Section title */
  .section-header {
    display: flex;
    align-items: baseline;
    gap: 16px;
    margin-bottom: 8px;
  }

  .section-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--amber);
    letter-spacing: 2px;
  }

  .section-title {
    font-family: 'Playfair Display', serif;
    font-size: 1.8rem;
    font-weight: 700;
  }

  .section-desc {
    font-style: italic;
    color: #555;
    margin-bottom: 28px;
    font-size: 1rem;
    max-width: 520px;
  }

  /* Canvas */
  canvas {
    display: block;
    border: 1px solid var(--grid-strong);
    background: #fff;
    box-shadow: 4px 4px 0 var(--ink);
  }

  .canvas-wrap {
    position: relative;
    display: inline-block;
  }

  .canvas-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--ink);
    background: var(--amber);
    padding: 4px 10px;
    position: absolute;
    top: -1px;
    right: -1px;
  }

  /* Controls */
  .control-group {
    margin-bottom: 24px;
    padding-bottom: 24px;
    border-bottom: 1px solid var(--grid-strong);
  }

  .control-group:last-child { border-bottom: none; }

  .control-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--teal);
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .control-value {
    color: var(--amber);
    font-size: 12px;
  }

  input[type=range] {
    -webkit-appearance: none;
    width: 100%;
    height: 2px;
    background: var(--grid-strong);
    outline: none;
    cursor: pointer;
    margin: 8px 0;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    background: var(--ink);
    border: 2px solid var(--amber);
    cursor: pointer;
  }

  /* Math formula display */
  .formula-box {
    background: var(--ink);
    color: var(--paper);
    padding: 16px 20px;
    margin: 20px 0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    line-height: 1.8;
    border-left: 3px solid var(--amber);
    position: relative;
  }

  .formula-box .formula-title {
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--amber);
    margin-bottom: 8px;
  }

  .formula-box .highlight { color: var(--amber-light); }
  .formula-box .dim { color: rgba(245,240,232,0.4); }

  /* Theory text */
  .theory {
    font-size: 0.95rem;
    line-height: 1.7;
    color: #333;
    margin-bottom: 16px;
  }

  .theory strong { color: var(--ink); font-weight: 600; }
  .theory em { color: var(--teal); }

  /* Toggle section */
  .panel { display: none; }
  .panel.active { display: block; }

  /* Buttons */
  .btn-row {
    display: flex;
    gap: 8px;
    margin: 16px 0;
    flex-wrap: wrap;
  }

  .btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    padding: 8px 16px;
    background: none;
    border: 1px solid var(--ink);
    cursor: pointer;
    transition: all 0.2s;
    color: var(--ink);
  }

  .btn:hover { background: var(--ink); color: var(--paper); }
  .btn.active { background: var(--teal); color: var(--paper); border-color: var(--teal); }

  /* Info callouts */
  .callout {
    border: 1px solid currentColor;
    padding: 12px 16px;
    margin: 16px 0;
    font-size: 0.9rem;
  }

  .callout.amber { color: var(--amber); border-color: var(--amber); background: rgba(200,146,42,0.06); }
  .callout.teal { color: var(--teal); border-color: var(--teal); background: rgba(26,107,107,0.06); }

  /* 3D canvas specific */
  #canvas3d {
    cursor: grab;
  }
  #canvas3d:active { cursor: grabbing; }

  /* Sidebar headings */
  .sb-title {
    font-family: 'Playfair Display', serif;
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 12px;
    margin-top: 4px;
  }

  /* Two canvas row */
  .canvas-row {
    display: flex;
    gap: 24px;
    flex-wrap: wrap;
    align-items: flex-start;
    margin-bottom: 24px;
  }

  .mini-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    text-transform: uppercase;
    text-align: center;
    margin-top: 6px;
    color: #888;
  }

  footer {
    text-align: center;
    padding: 40px;
    border-top: 1px solid var(--ink);
    font-size: 0.85rem;
    color: #888;
    font-style: italic;
  }

  @media (max-width: 900px) {
    .main { grid-template-columns: 1fr; }
    .sidebar { border-top: 1px solid var(--grid-strong); }
  }
</style>
</head>
<body>

<header>
  <div class="vol-label">Volume I · Interactive Atlas</div>
  <h1>Mathematical <em>Transformations</em></h1>
  <p class="subtitle">A rigorous visual exploration of linear, affine, and projective transformations in two and three dimensions</p>
</header>

<nav id="mainNav">
  <button class="active" onclick="showPanel('linear')">Linear Maps</button>
  <button onclick="showPanel('affine')">Affine</button>
  <button onclick="showPanel('eigen')">Eigenvectors</button>
  <button onclick="showPanel('proj3d')">3D Projection</button>
  <button onclick="showPanel('compose')">Composition</button>
  <button onclick="showPanel('fourier')">Fourier</button>
</nav>

<div class="main">
  <!-- ===================== LINEAR MAPS ===================== -->
  <div class="canvas-area panel active" id="panel-linear">
    <div class="section-header">
      <span class="section-num">§ 1</span>
      <h2 class="section-title">Linear Transformations</h2>
    </div>
    <p class="section-desc">Every linear map T: ℝ² → ℝ² is encoded by a 2×2 matrix. Drag the sliders to deform the unit grid in real time.</p>

    <div class="formula-box">
      <div class="formula-title">Matrix Equation</div>
      <span class="highlight">T(x) = Ax</span><br>
      <span class="dim">where A = </span>
      <span class="highlight">[[a, b], [c, d]]</span>
      <br><br>
      det(A) = <span id="detVal" class="highlight">1.00</span>
      &nbsp;|&nbsp; trace = <span id="traceVal" class="highlight">2.00</span>
    </div>

    <div class="canvas-wrap">
      <canvas id="linearCanvas" width="580" height="520"></canvas>
      <span class="canvas-label">Live Transform</span>
    </div>
  </div>

  <div class="sidebar panel active" id="sidebar-linear">
    <div class="sb-title">Matrix Controls</div>

    <div class="control-group">
      <div class="control-label">a (scale x) <span class="control-value" id="aVal">1.00</span></div>
      <input type="range" id="slA" min="-3" max="3" step="0.05" value="1">

      <div class="control-label">b (shear x) <span class="control-value" id="bVal">0.00</span></div>
      <input type="range" id="slB" min="-3" max="3" step="0.05" value="0">

      <div class="control-label">c (shear y) <span class="control-value" id="cVal">0.00</span></div>
      <input type="range" id="slC" min="-3" max="3" step="0.05" value="0">

      <div class="control-label">d (scale y) <span class="control-value" id="dVal">1.00</span></div>
      <input type="range" id="slD" min="-3" max="3" step="0.05" value="1">
    </div>

    <div class="btn-row">
      <button class="btn" onclick="setPreset('identity')">Identity</button>
      <button class="btn" onclick="setPreset('rotation45')">Rotate 45°</button>
      <button class="btn" onclick="setPreset('scale2')">Scale ×2</button>
      <button class="btn" onclick="setPreset('shear')">Shear</button>
      <button class="btn" onclick="setPreset('reflect')">Reflect X</button>
      <button class="btn" onclick="setPreset('project')">Project Y</button>
      <button class="btn" onclick="setPreset('singular')">Singular</button>
    </div>

    <div class="theory">
      A transformation is <strong>linear</strong> if it satisfies <em>T(u + v) = T(u) + T(v)</em> and <em>T(cv) = cT(v)</em>. This means the origin is always fixed and parallel lines remain parallel.
    </div>

    <div class="callout amber">
      <strong>det(A) = 0:</strong> The map collapses space into a lower dimension — the transformation is <em>singular</em>.
    </div>

    <div class="callout teal">
      <strong>|det(A)|</strong> measures the factor by which area is scaled. Negative determinant means orientation is reversed.
    </div>
  </div>

  <!-- ===================== AFFINE ===================== -->
  <div class="canvas-area panel" id="panel-affine">
    <div class="section-header">
      <span class="section-num">§ 2</span>
      <h2 class="section-title">Affine Transformations</h2>
    </div>
    <p class="section-desc">An affine map adds translation to linear: T(x) = Ax + b. The origin is no longer fixed.</p>

    <div class="formula-box">
      <div class="formula-title">Homogeneous Form</div>
      <span class="highlight">[x']   [a  b  tx] [x]</span><br>
      <span class="highlight">[y'] = [c  d  ty] [y]</span><br>
      <span class="highlight">[1 ]   [0  0   1] [1]</span>
    </div>

    <div class="canvas-wrap">
      <canvas id="affineCanvas" width="580" height="520"></canvas>
      <span class="canvas-label">Affine Map</span>
    </div>
  </div>

  <div class="sidebar panel" id="sidebar-affine">
    <div class="sb-title">Transform + Translate</div>

    <div class="control-group">
      <div class="control-label">Rotation θ <span class="control-value" id="affRotVal">0°</span></div>
      <input type="range" id="affRot" min="0" max="360" step="1" value="0">

      <div class="control-label">Scale <span class="control-value" id="affScaleVal">1.00</span></div>
      <input type="range" id="affScale" min="0.1" max="3" step="0.05" value="1">

      <div class="control-label">Shear X <span class="control-value" id="affShearVal">0.00</span></div>
      <input type="range" id="affShear" min="-2" max="2" step="0.05" value="0">

      <div class="control-label">Translate X <span class="control-value" id="affTxVal">0</span></div>
      <input type="range" id="affTx" min="-150" max="150" step="1" value="0">

      <div class="control-label">Translate Y <span class="control-value" id="affTy" min="-150" max="150">Translate Y <span class="control-value" id="affTyVal">0</span></div>
      <input type="range" id="affTySlider" min="-150" max="150" step="1" value="0">
    </div>

    <div class="theory">
      Affine transformations preserve <strong>collinearity</strong> (points on a line remain on a line) and <strong>ratios of distances</strong> along parallel lines — but not angles or distances in general.
    </div>

    <div class="callout teal">
      Every affine transformation of ℝ² can be expressed as a linear transformation in <em>homogeneous coordinates</em> ℝ³, embedding the plane as z=1.
    </div>
  </div>

  <!-- ===================== EIGEN ===================== -->
  <div class="canvas-area panel" id="panel-eigen">
    <div class="section-header">
      <span class="section-num">§ 3</span>
      <h2 class="section-title">Eigenvectors & Eigenvalues</h2>
    </div>
    <p class="section-desc">The eigenvectors of A are the directions that the transformation merely stretches or flips — never rotates.</p>

    <div class="formula-box">
      <div class="formula-title">Characteristic Equation</div>
      <span class="highlight">Av = λv</span><br>
      <span class="dim">⟺ (A - λI)v = 0</span><br>
      <span class="dim">⟺ det(A - λI) = 0</span><br><br>
      λ₁ = <span id="eig1" class="highlight">1.00</span>&nbsp;&nbsp;
      λ₂ = <span id="eig2" class="highlight">1.00</span>
    </div>

    <div class="canvas-wrap">
      <canvas id="eigenCanvas" width="580" height="520"></canvas>
      <span class="canvas-label">Eigenspace</span>
    </div>
  </div>

  <div class="sidebar panel" id="sidebar-eigen">
    <div class="sb-title">Matrix Entry</div>

    <div class="control-group">
      <div class="control-label">a₁₁ <span class="control-value" id="eA">2.00</span></div>
      <input type="range" id="eigA" min="-4" max="4" step="0.1" value="2">

      <div class="control-label">a₁₂ <span class="control-value" id="eB">1.00</span></div>
      <input type="range" id="eigB" min="-4" max="4" step="0.1" value="1">

      <div class="control-label">a₂₁ <span class="control-value" id="eC">0.00</span></div>
      <input type="range" id="eigC" min="-4" max="4" step="0.1" value="0">

      <div class="control-label">a₂₂ <span class="control-value" id="eD">3.00</span></div>
      <input type="range" id="eigD" min="-4" max="4" step="0.1" value="3">
    </div>

    <div class="btn-row">
      <button class="btn" onclick="toggleAnim('eigen')">▶ Animate</button>
    </div>

    <div class="theory">
      <strong>Eigenvectors</strong> (gold arrows) lie along invariant lines. <strong>Eigenvalues</strong> λ tell you the stretch factor along each eigenvector. When |λ| > 1, the vector grows; when |λ| < 1, it shrinks; λ < 0 means it flips.
    </div>

    <div class="callout amber">
      A 2×2 real matrix may have <em>complex eigenvalues</em> — occurring when the discriminant (tr A)² - 4·det A is negative. This indicates rotation in the transformation.
    </div>
  </div>

  <!-- ===================== 3D PROJECTION ===================== -->
  <div class="canvas-area panel" id="panel-proj3d">
    <div class="section-header">
      <span class="section-num">§ 4</span>
      <h2 class="section-title">3D Transformations & Projection</h2>
    </div>
    <p class="section-desc">Rotations in ℝ³ and perspective projection onto the 2D viewing plane. Drag to orbit.</p>

    <div class="formula-box">
      <div class="formula-title">Rotation Matrices</div>
      <span class="highlight">Rx(θ)</span> <span class="dim">= [[1,0,0],[0,cosθ,-sinθ],[0,sinθ,cosθ]]</span><br>
      <span class="highlight">Ry(φ)</span> <span class="dim">= [[cosφ,0,sinφ],[0,1,0],[-sinφ,0,cosφ]]</span><br>
      <span class="highlight">Rz(ψ)</span> <span class="dim">= [[cosψ,-sinψ,0],[sinψ,cosψ,0],[0,0,1]]</span>
    </div>

    <div class="canvas-wrap">
      <canvas id="canvas3d" width="580" height="520"></canvas>
      <span class="canvas-label">3D View — Drag to Orbit</span>
    </div>
  </div>

  <div class="sidebar panel" id="sidebar-proj3d">
    <div class="sb-title">3D Controls</div>

    <div class="control-group">
      <div class="control-label">Rotate X <span class="control-value" id="rx">0°</span></div>
      <input type="range" id="slRx" min="0" max="360" step="1" value="20">

      <div class="control-label">Rotate Y <span class="control-value" id="ry">0°</span></div>
      <input type="range" id="slRy" min="0" max="360" step="1" value="30">

      <div class="control-label">Rotate Z <span class="control-value" id="rz">0°</span></div>
      <input type="range" id="slRz" min="0" max="360" step="1" value="0">

      <div class="control-label">Perspective d <span class="control-value" id="perspD">4.00</span></div>
      <input type="range" id="slPersp" min="1" max="10" step="0.1" value="4">
    </div>

    <div class="btn-row">
      <button class="btn active" id="btnOrtho" onclick="toggleProjection('ortho')">Orthographic</button>
      <button class="btn" id="btnPersp" onclick="toggleProjection('persp')">Perspective</button>
    </div>

    <div class="btn-row">
      <button class="btn" onclick="show3dObject('cube')">Cube</button>
      <button class="btn" onclick="show3dObject('torus')">Torus</button>
      <button class="btn" onclick="show3dObject('axes')">Axes</button>
    </div>

    <div class="btn-row">
      <button class="btn" onclick="toggleAnim('3d')">▶ Auto Rotate</button>
    </div>

    <div class="theory">
      <strong>Orthographic projection</strong> drops the z-coordinate: (x,y,z) → (x,y). <strong>Perspective projection</strong> divides by z: (x,y,z) → (x/z, y/z), creating the foreshortening effect of human vision.
    </div>

    <div class="callout teal">
      The composition R = Rz·Ry·Rx is <em>not commutative</em> — order matters. This is the source of gimbal lock in Euler angles.
    </div>
  </div>

  <!-- ===================== COMPOSE ===================== -->
  <div class="canvas-area panel" id="panel-compose">
    <div class="section-header">
      <span class="section-num">§ 5</span>
      <h2 class="section-title">Composition of Transformations</h2>
    </div>
    <p class="section-desc">Apply two transformations sequentially. Observe that T₂∘T₁ ≠ T₁∘T₂ in general.</p>

    <div class="formula-box">
      <div class="formula-title">Composition Law</div>
      <span class="highlight">(T₂ ∘ T₁)(x) = T₂(T₁(x)) = B·(A·x) = (BA)·x</span><br><br>
      <span class="dim">Note: matrix multiplication is associative but NOT commutative</span>
    </div>

    <div class="canvas-row">
      <div>
        <div class="canvas-wrap">
          <canvas id="compA" width="260" height="240"></canvas>
          <span class="canvas-label">T₁</span>
        </div>
        <div class="mini-label">First Transform</div>
      </div>
      <div>
        <div class="canvas-wrap">
          <canvas id="compB" width="260" height="240"></canvas>
          <span class="canvas-label">T₂</span>
        </div>
        <div class="mini-label">Second Transform</div>
      </div>
    </div>

    <div class="canvas-wrap">
      <canvas id="compAB" width="580" height="220"></canvas>
      <span class="canvas-label">T₂ ∘ T₁ Combined</span>
    </div>
  </div>

  <div class="sidebar panel" id="sidebar-compose">
    <div class="sb-title">Transform T₁</div>
    <div class="control-group">
      <div class="control-label">Angle <span class="control-value" id="compAngle1">0°</span></div>
      <input type="range" id="cAng1" min="0" max="360" step="1" value="0">
      <div class="control-label">Scale X <span class="control-value" id="compSx1">1.00</span></div>
      <input type="range" id="cSx1" min="-2" max="2" step="0.05" value="1">
      <div class="control-label">Scale Y <span class="control-value" id="compSy1">1.00</span></div>
      <input type="range" id="cSy1" min="-2" max="2" step="0.05" value="1">
    </div>

    <div class="sb-title">Transform T₂</div>
    <div class="control-group">
      <div class="control-label">Angle <span class="control-value" id="compAngle2">0°</span></div>
      <input type="range" id="cAng2" min="0" max="360" step="1" value="0">
      <div class="control-label">Scale X <span class="control-value" id="compSx2">1.00</span></div>
      <input type="range" id="cSx2" min="-2" max="2" step="0.05" value="1">
      <div class="control-label">Shear <span class="control-value" id="compSh2">0.00</span></div>
      <input type="range" id="cSh2" min="-2" max="2" step="0.05" value="0">
    </div>

    <div class="theory">
      The resulting matrix <em>BA</em> is the product of B and A, computed right-to-left. Swap the order to see <em>AB</em> — the shape will generally differ.
    </div>

    <div class="btn-row">
      <button class="btn" onclick="swapCompose()">⇄ Swap Order</button>
    </div>
  </div>

  <!-- ===================== FOURIER ===================== -->
  <div class="canvas-area panel" id="panel-fourier">
    <div class="section-header">
      <span class="section-num">§ 6</span>
      <h2 class="section-title">Fourier Transform</h2>
    </div>
    <p class="section-desc">The DFT is a linear transformation that maps a signal from the time domain into the frequency domain.</p>

    <div class="formula-box">
      <div class="formula-title">Discrete Fourier Transform</div>
      <span class="highlight">X[k] = Σₙ x[n] · e^(-i·2π·k·n/N)</span><br><br>
      <span class="dim">e^(iθ) = cos(θ) + i·sin(θ)</span>&nbsp;&nbsp;<span class="highlight">← Euler's Formula</span>
    </div>

    <div class="canvas-wrap" style="margin-bottom:20px">
      <canvas id="fourierCanvas" width="580" height="260"></canvas>
      <span class="canvas-label">Time Domain</span>
    </div>
    <div class="canvas-wrap">
      <canvas id="fourierFreq" width="580" height="200"></canvas>
      <span class="canvas-label">Frequency Domain</span>
    </div>
  </div>

  <div class="sidebar panel" id="sidebar-fourier">
    <div class="sb-title">Signal Composer</div>
    <div class="control-group">
      <div class="control-label">Frequency 1 (Hz) <span class="control-value" id="f1v">2</span></div>
      <input type="range" id="freq1" min="1" max="15" step="1" value="2">
      <div class="control-label">Amplitude 1 <span class="control-value" id="a1v">1.0</span></div>
      <input type="range" id="amp1" min="0" max="2" step="0.1" value="1">

      <div class="control-label">Frequency 2 (Hz) <span class="control-value" id="f2v">5</span></div>
      <input type="range" id="freq2" min="1" max="15" step="1" value="5">
      <div class="control-label">Amplitude 2 <span class="control-value" id="a2v">0.5</span></div>
      <input type="range" id="amp2" min="0" max="2" step="0.1" value="0.5">

      <div class="control-label">Frequency 3 (Hz) <span class="control-value" id="f3v">10</span></div>
      <input type="range" id="freq3" min="1" max="15" step="1" value="10">
      <div class="control-label">Amplitude 3 <span class="control-value" id="a3v">0.3</span></div>
      <input type="range" id="amp3" min="0" max="2" step="0.1" value="0.3">
    </div>

    <div class="btn-row">
      <button class="btn" onclick="setSignalPreset('sine')">Pure Sine</button>
      <button class="btn" onclick="setSignalPreset('square')">Square Wave</button>
      <button class="btn" onclick="setSignalPreset('sawtooth')">Sawtooth</button>
    </div>

    <div class="theory">
      The DFT reveals <strong>which frequencies</strong> make up a signal. Each spike in the frequency domain corresponds to a sinusoidal component in the time domain.
    </div>

    <div class="callout amber">
      The DFT matrix is <em>unitary</em> — it preserves energy (Parseval's theorem). This makes it a proper isometry of the signal space.
    </div>
  </div>
</div>

<footer>Mathematical Transformations Atlas · Built with canvas2D & WebGL-style rendering · All transformations computed in real time</footer>

<script>
// ============================================================
//  UTILITIES
// ============================================================
const $ = id => document.getElementById(id);
const τ = Math.PI * 2;

function showPanel(name) {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
  $('panel-' + name).classList.add('active');
  $('sidebar-' + name).classList.add('active');
  event.target.classList.add('active');
  requestAnimationFrame(() => {
    if (name === 'linear') drawLinear();
    if (name === 'affine') drawAffine();
    if (name === 'eigen') drawEigen();
    if (name === 'proj3d') draw3D();
    if (name === 'compose') drawCompose();
    if (name === 'fourier') drawFourier();
  });
}

// ============================================================
//  §1 LINEAR TRANSFORMATIONS
// ============================================================
const lc = $('linearCanvas');
const lctx = lc.getContext('2d');
let A = [1,0,0,1]; // [a,b,c,d]
let animStates = {};

function getMatrix() {
  return [
    parseFloat($('slA').value),
    parseFloat($('slB').value),
    parseFloat($('slC').value),
    parseFloat($('slD').value)
  ];
}

function drawLinear() {
  const [a,b,c,d] = getMatrix();
  const W = lc.width, H = lc.height;
  const cx = W/2, cy = H/2;
  const scale = 55;
  lctx.clearRect(0,0,W,H);

  // Background grid (original)
  drawGrid2D(lctx, cx, cy, scale, W, H, 'rgba(200,200,200,0.5)', false, [1,0,0,1]);

  // Transformed grid
  drawGrid2D(lctx, cx, cy, scale, W, H, null, true, [a,b,c,d]);

  // Axes
  drawArrow(lctx, cx, cy, cx + a*scale, cy - c*scale, '#c8922a', 3);
  drawArrow(lctx, cx, cy, cx + b*scale, cy - d*scale, '#1a6b6b', 3);

  // Unit square
  const pts = [[0,0],[1,0],[1,1],[0,1]];
  lctx.beginPath();
  pts.forEach(([px,py],i) => {
    const tx = cx + (a*px + b*py)*scale;
    const ty = cy - (c*px + d*py)*scale;
    i===0 ? lctx.moveTo(tx,ty) : lctx.lineTo(tx,ty);
  });
  lctx.closePath();
  lctx.fillStyle = 'rgba(200,146,42,0.18)';
  lctx.fill();
  lctx.strokeStyle = '#c8922a';
  lctx.lineWidth = 2;
  lctx.stroke();

  // Determinant display
  const det = a*d - b*c;
  const trace = a + d;
  $('detVal').textContent = det.toFixed(2);
  $('traceVal').textContent = trace.toFixed(2);
  $('aVal').textContent = a.toFixed(2);
  $('bVal').textContent = b.toFixed(2);
  $('cVal').textContent = c.toFixed(2);
  $('dVal').textContent = d.toFixed(2);

  // Labels
  lctx.font = '13px JetBrains Mono, monospace';
  lctx.fillStyle = '#c8922a';
  lctx.fillText(`e₁'=(${a.toFixed(1)},${c.toFixed(1)})`, cx+a*scale+8, cy-c*scale-6);
  lctx.fillStyle = '#1a6b6b';
  lctx.fillText(`e₂'=(${b.toFixed(1)},${d.toFixed(1)})`, cx+b*scale+8, cy-d*scale-6);
}

function drawGrid2D(ctx, cx, cy, scale, W, H, color, transformed, mat) {
  const [a,b,c,d] = mat;
  ctx.save();
  ctx.strokeStyle = color || 'rgba(26,107,107,0.4)';
  ctx.lineWidth = transformed ? 1 : 0.5;

  const range = 6;
  for (let i = -range; i <= range; i++) {
    // Horizontal lines (y = i)
    ctx.beginPath();
    const x0 = a*(-range) + b*i, y0 = c*(-range) + d*i;
    const x1 = a*range + b*i, y1 = c*range + d*i;
    ctx.moveTo(cx + x0*scale, cy - y0*scale);
    ctx.lineTo(cx + x1*scale, cy - y1*scale);
    if (i === 0 && transformed) { ctx.strokeStyle = '#2a9d8f'; ctx.lineWidth = 2; }
    else { ctx.strokeStyle = color || 'rgba(26,107,107,0.25)'; ctx.lineWidth = 0.5; }
    ctx.stroke();

    // Vertical lines (x = i)
    ctx.beginPath();
    const x2 = a*i + b*(-range), y2 = c*i + d*(-range);
    const x3 = a*i + b*range, y3 = c*i + d*range;
    ctx.moveTo(cx + x2*scale, cy - y2*scale);
    ctx.lineTo(cx + x3*scale, cy - y3*scale);
    if (i === 0 && transformed) { ctx.strokeStyle = '#c8922a'; ctx.lineWidth = 2; }
    else { ctx.strokeStyle = color || 'rgba(26,107,107,0.25)'; ctx.lineWidth = 0.5; }
    ctx.stroke();
  }
  ctx.restore();
}

function drawArrow(ctx, x1,y1,x2,y2,color,lw) {
  ctx.save();
  ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = lw;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  const ang = Math.atan2(y2-y1, x2-x1);
  const hs = 10;
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-hs*Math.cos(ang-0.4), y2-hs*Math.sin(ang-0.4));
  ctx.lineTo(x2-hs*Math.cos(ang+0.4), y2-hs*Math.sin(ang+0.4));
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

// Presets
const presets = {
  identity:  [1,0,0,1],
  rotation45:[Math.cos(Math.PI/4),-Math.sin(Math.PI/4),Math.sin(Math.PI/4),Math.cos(Math.PI/4)],
  scale2:    [2,0,0,2],
  shear:     [1,1,0,1],
  reflect:   [1,0,0,-1],
  project:   [1,0,0,0],
  singular:  [1,2,0.5,1],
};

function setPreset(name) {
  const [a,b,c,d] = presets[name];
  $('slA').value = a; $('slB').value = b;
  $('slC').value = c; $('slD').value = d;
  drawLinear();
}

['slA','slB','slC','slD'].forEach(id => $(id).addEventListener('input', drawLinear));

// ============================================================
//  §2 AFFINE
// ============================================================
const ac = $('affineCanvas');
const actx = ac.getContext('2d');

function drawAffine() {
  const θ = parseFloat($('affRot').value) * Math.PI / 180;
  const s = parseFloat($('affScale').value);
  const sh = parseFloat($('affShear').value);
  const tx = parseFloat($('affTx').value);
  const ty = parseFloat($('affTySlider').value);

  $('affRotVal').textContent = Math.round(θ*180/Math.PI) + '°';
  $('affScaleVal').textContent = s.toFixed(2);
  $('affShearVal').textContent = sh.toFixed(2);
  $('affTxVal').textContent = tx;
  $('affTyVal').textContent = ty;

  const W = ac.width, H = ac.height;
  const cx = W/2, cy = H/2;
  const sc = 55;
  actx.clearRect(0,0,W,H);

  // Original light grid
  drawGrid2D(actx, cx, cy, sc, W, H, 'rgba(200,200,200,0.5)', false, [1,0,0,1]);

  // Compose: shear * rotation * scale
  const cosθ = Math.cos(θ), sinθ = Math.sin(θ);
  const a = s*cosθ, b = s*(-sinθ) + sh*s*cosθ;
  const c = s*sinθ, d = s*cosθ + sh*s*sinθ;

  // Draw transformed grid with translation
  actx.save();
  actx.translate(tx, -ty);
  drawGrid2D(actx, cx, cy, sc, W, H, null, true, [a,b,c,d]);
  actx.restore();

  // Draw a house shape
  const house = [[0,0],[2,0],[2,1.5],[1,2.5],[0,1.5]];
  // Original
  actx.save();
  actx.strokeStyle = 'rgba(150,150,150,0.5)';
  actx.lineWidth = 1;
  actx.setLineDash([4,4]);
  actx.beginPath();
  house.forEach(([x,y],i) => {
    const px = cx + x*sc, py = cy - y*sc;
    i===0 ? actx.moveTo(px,py) : actx.lineTo(px,py);
  });
  actx.closePath(); actx.stroke();
  actx.restore();

  // Transformed
  actx.beginPath();
  house.forEach(([x,y],i) => {
    const nx = a*x + b*y + tx + cx;
    const ny = -(c*x + d*y) + ty + cy;
    i===0 ? actx.moveTo(nx,ny) : actx.lineTo(nx,ny);
  });
  actx.closePath();
  actx.fillStyle = 'rgba(26,107,107,0.15)';
  actx.fill();
  actx.strokeStyle = '#1a6b6b';
  actx.lineWidth = 2;
  actx.stroke();

  // Origin dot
  actx.beginPath();
  actx.arc(cx+tx, cy+ty, 5, 0, τ);
  actx.fillStyle = '#8b3a52';
  actx.fill();
  actx.font = '12px JetBrains Mono';
  actx.fillStyle = '#8b3a52';
  actx.fillText('origin → translated', cx+tx+8, cy+ty-6);
}

['affRot','affScale','affShear','affTx','affTySlider'].forEach(id => $(id).addEventListener('input', drawAffine));

// ============================================================
//  §3 EIGENVECTORS
// ============================================================
const ec = $('eigenCanvas');
const ectx = ec.getContext('2d');
let eigAnim = false, eigT = 0;

function computeEigen(a,b,c,d) {
  const tr = a + d, det = a*d - b*c;
  const disc = tr*tr - 4*det;
  if (disc < 0) return { complex: true, tr, det };
  const l1 = (tr + Math.sqrt(disc)) / 2;
  const l2 = (tr - Math.sqrt(disc)) / 2;
  // Eigenvectors
  let v1, v2;
  if (Math.abs(b) > 1e-10) {
    v1 = [b, l1-a]; v2 = [b, l2-a];
  } else if (Math.abs(c) > 1e-10) {
    v1 = [l1-d, c]; v2 = [l2-d, c];
  } else {
    v1 = [1,0]; v2 = [0,1];
  }
  const norm1 = Math.sqrt(v1[0]*v1[0]+v1[1]*v1[1]);
  const norm2 = Math.sqrt(v2[0]*v2[0]+v2[1]*v2[1]);
  if (norm1>0) { v1[0]/=norm1; v1[1]/=norm1; }
  if (norm2>0) { v2[0]/=norm2; v2[1]/=norm2; }
  return { l1, l2, v1, v2, complex: false };
}

function drawEigen() {
  const a = parseFloat($('eigA').value);
  const b = parseFloat($('eigB').value);
  const c = parseFloat($('eigC').value);
  const d = parseFloat($('eigD').value);
  $('eA').textContent = a.toFixed(2);
  $('eB').textContent = b.toFixed(2);
  $('eC').textContent = c.toFixed(2);
  $('eD').textContent = d.toFixed(2);

  const W = ec.width, H = ec.height;
  const cx = W/2, cy = H/2, sc = 65;
  ectx.clearRect(0,0,W,H);

  // Grid
  drawGrid2D(ectx, cx, cy, sc, W, H, 'rgba(200,200,200,0.4)', false, [1,0,0,1]);
  drawGrid2D(ectx, cx, cy, sc, W, H, null, true, [a,b,c,d]);

  const eigen = computeEigen(a,b,c,d);

  if (!eigen.complex) {
    $('eig1').textContent = eigen.l1.toFixed(3);
    $('eig2').textContent = eigen.l2.toFixed(3);

    // Eigenvector lines (full lines through origin)
    const {v1, v2, l1, l2} = eigen;
    const len = 250;

    // Draw eigenvector lines
    [v1, v2].forEach((v, idx) => {
      ectx.beginPath();
      ectx.moveTo(cx - v[0]*len, cy + v[1]*len);
      ectx.lineTo(cx + v[0]*len, cy - v[1]*len);
      ectx.strokeStyle = idx===0 ? 'rgba(200,146,42,0.3)' : 'rgba(139,58,82,0.3)';
      ectx.lineWidth = 1;
      ectx.setLineDash([6,4]);
      ectx.stroke();
      ectx.setLineDash([]);
    });

    // Animate t: show Aᵗv
    const t = eigAnim ? eigT : 1;
    const lt1 = Math.pow(Math.abs(l1), t) * Math.sign(l1);
    const lt2 = Math.pow(Math.abs(l2), t) * Math.sign(l2);

    const arrowSc = sc * 1.5;
    drawArrow(ectx, cx, cy, cx+v1[0]*lt1*arrowSc, cy-v1[1]*lt1*arrowSc, '#c8922a', 3);
    drawArrow(ectx, cx, cy, cx+v2[0]*lt2*arrowSc, cy-v2[1]*lt2*arrowSc, '#8b3a52', 3);

    // Labels
    ectx.font = '13px JetBrains Mono, monospace';
    ectx.fillStyle = '#c8922a';
    ectx.fillText(`v₁, λ₁=${l1.toFixed(2)}`, cx+v1[0]*arrowSc+10, cy-v1[1]*arrowSc-10);
    ectx.fillStyle = '#8b3a52';
    ectx.fillText(`v₂, λ₂=${l2.toFixed(2)}`, cx+v2[0]*arrowSc+10, cy-v2[1]*arrowSc-10);

  } else {
    $('eig1').textContent = 'complex';
    $('eig2').textContent = 'complex';
    ectx.save();
    ectx.font = 'italic 18px Crimson Pro, serif';
    ectx.fillStyle = '#8b3a52';
    ectx.textAlign = 'center';
    ectx.fillText('Complex eigenvalues — rotation present', cx, cy - 20);
    const tr = (a+d)/2, det = a*d-b*c;
    const im = Math.sqrt(det - tr*tr);
    ectx.fillStyle = '#555';
    ectx.font = '14px JetBrains Mono, monospace';
    ectx.fillText(`λ = ${tr.toFixed(2)} ± ${im.toFixed(2)}i`, cx, cy + 10);
    ectx.restore();

    // Draw a spiral to indicate rotation
    ectx.beginPath();
    for (let t=0; t<6*Math.PI; t+=0.05) {
      const r = t * sc * 0.08;
      const angle = t + Math.atan2(im, tr);
      const x = cx + r*Math.cos(angle);
      const y = cy - r*Math.sin(angle);
      t===0 ? ectx.moveTo(x,y) : ectx.lineTo(x,y);
    }
    ectx.strokeStyle = '#8b3a52';
    ectx.lineWidth = 1.5;
    ectx.stroke();
  }
}

['eigA','eigB','eigC','eigD'].forEach(id => $(id).addEventListener('input', drawEigen));

function toggleAnim(type) {
  if (type === 'eigen') {
    eigAnim = !eigAnim;
    if (eigAnim) animEigen();
  } else if (type === '3d') {
    anim3d = !anim3d;
    if (anim3d) animate3D();
  }
}

function animEigen() {
  if (!eigAnim) return;
  eigT += 0.02;
  if (eigT > 2) eigT = 0;
  drawEigen();
  requestAnimationFrame(animEigen);
}

// ============================================================
//  §4 3D TRANSFORMATIONS
// ============================================================
const c3 = $('canvas3d');
const ctx3 = c3.getContext('2d');
let projMode = 'ortho', obj3d = 'cube', anim3d = false, anim3dT = 0;
let isDragging = false, lastMouse = null, rotOffset = [0,0];

function rotatePt(pt, rx, ry, rz) {
  let [x,y,z] = pt;
  // Rx
  let ny = y*Math.cos(rx) - z*Math.sin(rx);
  let nz = y*Math.sin(rx) + z*Math.cos(rx);
  y=ny; z=nz;
  // Ry
  let nx = x*Math.cos(ry) + z*Math.sin(ry);
  nz = -x*Math.sin(ry) + z*Math.cos(ry);
  x=nx; z=nz;
  // Rz
  nx = x*Math.cos(rz) - y*Math.sin(rz);
  ny = x*Math.sin(rz) + y*Math.cos(rz);
  return [nx,ny,nz];
}

function project(pt, d) {
  const [x,y,z] = pt;
  if (projMode === 'ortho') return [x,y];
  const zd = z + d;
  if (Math.abs(zd) < 0.01) return [x*100, y*100];
  return [x*d/zd, y*d/zd];
}

function getCubeEdges() {
  const v = [];
  for (let x of [-1,1]) for (let y of [-1,1]) for (let z of [-1,1]) v.push([x,y,z]);
  const edges = [];
  for (let i=0; i<v.length; i++) for (let j=i+1; j<v.length; j++) {
    const diff = v[i].map((c,k)=>Math.abs(c-v[j][k]));
    if (diff.filter(d=>d>0).length===1) edges.push([v[i],v[j]]);
  }
  return {verts: v, edges};
}

function getTorusPoints() {
  const pts = [], lines = [];
  const R=1.4, r=0.5, nu=24, nv=16;
  for (let i=0; i<nu; i++) {
    for (let j=0; j<nv; j++) {
      const u = i/nu*τ, v = j/nv*τ;
      pts.push([(R+r*Math.cos(v))*Math.cos(u),(R+r*Math.cos(v))*Math.sin(u),r*Math.sin(v)]);
    }
  }
  // edges
  for (let i=0; i<nu; i++) for (let j=0; j<nv; j++) {
    lines.push([pts[i*nv+j], pts[((i+1)%nu)*nv+j]]);
    lines.push([pts[i*nv+j], pts[i*nv+(j+1)%nv]]);
  }
  return {verts: pts, edges: lines};
}

function getAxesLines() {
  return { verts: [], edges: [
    {pts:[[0,0,0],[2.5,0,0]], color:'#c8922a'},
    {pts:[[0,0,0],[0,2.5,0]], color:'#1a6b6b'},
    {pts:[[0,0,0],[0,0,2.5]], color:'#8b3a52'},
  ]};
}

function draw3D() {
  const rx = (parseFloat($('slRx').value) + rotOffset[0]) * Math.PI/180;
  const ry = (parseFloat($('slRy').value) + rotOffset[1]) * Math.PI/180;
  const rz = parseFloat($('slRz').value) * Math.PI/180;
  const d  = parseFloat($('slPersp').value);

  $('rx').textContent = Math.round(rx*180/Math.PI) + '°';
  $('ry').textContent = Math.round(ry*180/Math.PI) + '°';
  $('rz').textContent = Math.round(rz*180/Math.PI) + '°';
  $('perspD').textContent = d.toFixed(1);

  const W = c3.width, H = c3.height;
  const cx = W/2, cy = H/2;
  const sc = projMode === 'ortho' ? 90 : 120;

  ctx3.clearRect(0,0,W,H);

  // Draw subtle grid on "floor" (y=-1 plane)
  ctx3.save();
  for (let i=-3; i<=3; i++) {
    const p1 = rotatePt([i,-1.5,-3], rx, ry, rz);
    const p2 = rotatePt([i,-1.5,3], rx, ry, rz);
    const p3 = rotatePt([-3,-1.5,i], rx, ry, rz);
    const p4 = rotatePt([3,-1.5,i], rx, ry, rz);
    [[p1,p2],[p3,p4]].forEach(([a,b]) => {
      const [ax,ay] = project(a, d);
      const [bx,by] = project(b, d);
      ctx3.beginPath();
      ctx3.moveTo(cx+ax*sc, cy-ay*sc);
      ctx3.lineTo(cx+bx*sc, cy-by*sc);
      ctx3.strokeStyle = 'rgba(100,100,100,0.2)';
      ctx3.lineWidth = 0.5;
      ctx3.stroke();
    });
  }
  ctx3.restore();

  // Draw object
  let obj;
  if (obj3d === 'cube') obj = getCubeEdges();
  else if (obj3d === 'torus') obj = getTorusPoints();
  else obj = null;

  if (obj && obj.edges) {
    obj.edges.forEach(edge => {
      const pts = edge.pts || edge;
      const p0 = Array.isArray(pts[0]) ? pts[0] : edge[0];
      const p1b = Array.isArray(pts[1]) ? pts[1] : edge[1];
      const r0 = rotatePt(p0, rx, ry, rz);
      const r1 = rotatePt(p1b, rx, ry, rz);
      const [ax,ay] = project(r0, d);
      const [bx,by] = project(r1, d);

      const depth = (r0[2]+r1[2])/2;
      const brightness = Math.round(180 - depth*30);
      ctx3.beginPath();
      ctx3.moveTo(cx+ax*sc, cy-ay*sc);
      ctx3.lineTo(cx+bx*sc, cy-by*sc);
      ctx3.strokeStyle = edge.color || `rgb(${brightness},${brightness+30},${brightness+60})`;
      ctx3.lineWidth = obj3d==='torus' ? 0.7 : 1.5;
      ctx3.stroke();
    });
  }

  // Draw axes
  const axData = [
    { dir:[1.8,0,0], color:'#c8922a', label:'X' },
    { dir:[0,1.8,0], color:'#1a6b6b', label:'Y' },
    { dir:[0,0,1.8], color:'#8b3a52', label:'Z' },
  ];
  axData.forEach(({dir,color,label}) => {
    const r = rotatePt(dir, rx, ry, rz);
    const [px,py] = project(r, d);
    drawArrow(ctx3, cx, cy, cx+px*sc, cy-py*sc, color, 2);
    ctx3.font = 'bold 14px JetBrains Mono';
    ctx3.fillStyle = color;
    ctx3.fillText(label, cx+px*sc+8, cy-py*sc-6);
  });

  // Vertices for cube
  if (obj3d === 'cube' && obj) {
    obj.verts.forEach(v => {
      const r = rotatePt(v, rx, ry, rz);
      const [px,py] = project(r, d);
      ctx3.beginPath();
      ctx3.arc(cx+px*sc, cy-py*sc, 4, 0, τ);
      ctx3.fillStyle = '#2d3561';
      ctx3.fill();
    });
  }
}

function toggleProjection(mode) {
  projMode = mode;
  $('btnOrtho').classList.toggle('active', mode==='ortho');
  $('btnPersp').classList.toggle('active', mode==='persp');
  draw3D();
}

function show3dObject(o) { obj3d = o; draw3D(); }

['slRx','slRy','slRz','slPersp'].forEach(id => $(id).addEventListener('input', draw3D));

// Mouse orbit
c3.addEventListener('mousedown', e => { isDragging=true; lastMouse=[e.clientX,e.clientY]; });
window.addEventListener('mouseup', () => isDragging=false);
window.addEventListener('mousemove', e => {
  if (!isDragging || !lastMouse) return;
  const dx = e.clientX - lastMouse[0];
  const dy = e.clientY - lastMouse[1];
  rotOffset[1] += dx * 0.5;
  rotOffset[0] += dy * 0.5;
  lastMouse = [e.clientX, e.clientY];
  draw3D();
});

function animate3D() {
  if (!anim3d) return;
  rotOffset[1] += 0.5;
  draw3D();
  requestAnimationFrame(animate3D);
}

// ============================================================
//  §5 COMPOSITION
// ============================================================
const ccA = $('compA'), ccB = $('compB'), ccAB = $('compAB');
const ctxA = ccA.getContext('2d'), ctxB = ccB.getContext('2d'), ctxAB = ccAB.getContext('2d');
let compSwapped = false;

function getCompMat1() {
  const θ = parseFloat($('cAng1').value)*Math.PI/180;
  const sx = parseFloat($('cSx1').value);
  const sy = parseFloat($('cSy1').value);
  return [sx*Math.cos(θ), -sy*Math.sin(θ), sx*Math.sin(θ), sy*Math.cos(θ)];
}

function getCompMat2() {
  const θ = parseFloat($('cAng2').value)*Math.PI/180;
  const sx = parseFloat($('cSx2').value);
  const sh = parseFloat($('cSh2').value);
  return [sx*Math.cos(θ), -Math.sin(θ)+sh*Math.cos(θ), sx*Math.sin(θ), Math.cos(θ)+sh*Math.sin(θ)];
}

function matMul(A, B) {
  const [a,b,c,d] = A, [e,f,g,h] = B;
  return [a*e+b*g, a*f+b*h, c*e+d*g, c*f+d*h];
}

function miniGrid(ctx, mat, W, H, color) {
  const cx=W/2, cy=H/2, sc=35;
  ctx.clearRect(0,0,W,H);
  drawGrid2D(ctx,cx,cy,sc,W,H,'rgba(200,200,200,0.5)',false,[1,0,0,1]);
  drawGrid2D(ctx,cx,cy,sc,W,H,null,true,mat);
  const [a,b,c,d] = mat;
  drawArrow(ctx,cx,cy,cx+a*sc,cy-c*sc,color,2);
  drawArrow(ctx,cx,cy,cx+b*sc,cy-d*sc,'#8b3a52',2);
}

function drawCompose() {
  const M1 = getCompMat1(), M2 = getCompMat2();
  $('compAngle1').textContent = $('cAng1').value+'°';
  $('compSx1').textContent = parseFloat($('cSx1').value).toFixed(2);
  $('compSy1').textContent = parseFloat($('cSy1').value).toFixed(2);
  $('compAngle2').textContent = $('cAng2').value+'°';
  $('compSx2').textContent = parseFloat($('cSx2').value).toFixed(2);
  $('compSh2').textContent = parseFloat($('cSh2').value).toFixed(2);

  miniGrid(ctxA, M1, ccA.width, ccA.height, '#c8922a');
  miniGrid(ctxB, M2, ccB.width, ccB.height, '#1a6b6b');

  const combined = compSwapped ? matMul(M1, M2) : matMul(M2, M1);

  // Big combined canvas
  const W=ccAB.width, H=ccAB.height, cx=W/2, cy=H/2, sc=45;
  ctxAB.clearRect(0,0,W,H);
  drawGrid2D(ctxAB,cx,cy,sc,W,H,'rgba(200,200,200,0.5)',false,[1,0,0,1]);
  drawGrid2D(ctxAB,cx,cy,sc,W,H,null,true,combined);

  const [a,b,c,d] = combined;
  drawArrow(ctxAB,cx,cy,cx+a*sc,cy-c*sc,'#c8922a',3);
  drawArrow(ctxAB,cx,cy,cx+b*sc,cy-d*sc,'#1a6b6b',3);
  ctxAB.font='12px JetBrains Mono';
  ctxAB.fillStyle='#555';
  const order = compSwapped ? 'T₁∘T₂ (swapped)' : 'T₂∘T₁';
  ctxAB.fillText(`Combined: ${order}`, 12, 20);
}

function swapCompose() { compSwapped = !compSwapped; drawCompose(); }

['cAng1','cSx1','cSy1','cAng2','cSx2','cSh2'].forEach(id => $(id).addEventListener('input', drawCompose));

// ============================================================
//  §6 FOURIER
// ============================================================
const fcT = $('fourierCanvas'), fcF = $('fourierFreq');
const fctx = fcT.getContext('2d'), fctxF = fcF.getContext('2d');

function getSignal(N) {
  const f1=parseInt($('freq1').value), a1=parseFloat($('amp1').value);
  const f2=parseInt($('freq2').value), a2=parseFloat($('amp2').value);
  const f3=parseInt($('freq3').value), a3=parseFloat($('amp3').value);
  $('f1v').textContent=f1; $('a1v').textContent=a1.toFixed(1);
  $('f2v').textContent=f2; $('a2v').textContent=a2.toFixed(1);
  $('f3v').textContent=f3; $('a3v').textContent=a3.toFixed(1);
  const sig = [];
  for (let n=0; n<N; n++) {
    const t = n/N;
    sig.push(a1*Math.sin(τ*f1*t) + a2*Math.sin(τ*f2*t) + a3*Math.sin(τ*f3*t));
  }
  return sig;
}

function dft(x) {
  const N = x.length, X = [];
  for (let k=0; k<N/2; k++) {
    let re=0, im=0;
    for (let n=0; n<N; n++) {
      re += x[n]*Math.cos(τ*k*n/N);
      im -= x[n]*Math.sin(τ*k*n/N);
    }
    X.push(Math.sqrt(re*re+im*im)/N);
  }
  return X;
}

function drawFourier() {
  const N = 256;
  const sig = getSignal(N);
  const W = fcT.width, H = fcT.height;
  const cy = H/2;

  fctx.clearRect(0,0,W,H);

  // Grid
  fctx.strokeStyle = 'rgba(200,200,200,0.5)';
  fctx.lineWidth = 0.5;
  [0.25,0.5,0.75].forEach(f => {
    fctx.beginPath();
    fctx.moveTo(0,H*f); fctx.lineTo(W,H*f);
    fctx.stroke();
  });

  // Signal
  fctx.beginPath();
  sig.forEach((v, i) => {
    const x = i/N*W, y = cy - v*(H*0.38);
    i===0 ? fctx.moveTo(x,y) : fctx.lineTo(x,y);
  });
  fctx.strokeStyle = '#2d3561';
  fctx.lineWidth = 2;
  fctx.stroke();

  // Axis
  fctx.beginPath(); fctx.moveTo(0,cy); fctx.lineTo(W,cy);
  fctx.strokeStyle='rgba(0,0,0,0.2)'; fctx.lineWidth=1; fctx.stroke();

  fctx.font='11px JetBrains Mono';
  fctx.fillStyle='#888';
  fctx.fillText('t →', W-30, cy-6);

  // Frequency domain
  const Xmag = dft(sig);
  const FW = fcF.width, FH = fcF.height;
  fctxF.clearRect(0,0,FW,FH);

  // BG
  fctxF.fillStyle='#0a0a12';
  fctxF.fillRect(0,0,FW,FH);

  const maxX = Math.max(...Xmag, 0.01);
  const barW = FW/Xmag.length;

  Xmag.forEach((v, k) => {
    const barH = (v/maxX)*(FH-30);
    const hue = 200 + k/Xmag.length*120;
    fctxF.fillStyle = `hsl(${hue},70%,65%)`;
    fctxF.fillRect(k*barW, FH-barH-20, Math.max(barW-1,1), barH);
  });

  // Highlight peaks
  Xmag.forEach((v,k) => {
    if (v > maxX*0.15) {
      fctxF.font='10px JetBrains Mono';
      fctxF.fillStyle='#e8b84b';
      fctxF.fillText(k+'Hz', k*barW, FH-((v/maxX)*(FH-30))-24);
    }
  });

  fctxF.font='11px JetBrains Mono';
  fctxF.fillStyle='#888';
  fctxF.fillText('k (frequency) →', FW-130, FH-4);
  fctxF.fillStyle='rgba(245,240,232,0.5)';
  fctxF.fillText('|X[k]|', 8, 16);
}

function setSignalPreset(type) {
  if (type==='square') {
    $('freq1').value=2; $('amp1').value=1;
    $('freq2').value=6; $('amp2').value=0.33;
    $('freq3').value=10; $('amp3').value=0.2;
  } else if (type==='sawtooth') {
    $('freq1').value=3; $('amp1').value=1;
    $('freq2').value=6; $('amp2').value=0.5;
    $('freq3').value=9; $('amp3').value=0.33;
  } else {
    $('freq1').value=4; $('amp1').value=1.5;
    $('freq2').value=4; $('amp2').value=0;
    $('freq3').value=4; $('amp3').value=0;
  }
  drawFourier();
}

['freq1','amp1','freq2','amp2','freq3','amp3'].forEach(id => $(id).addEventListener('input', drawFourier));

// ============================================================
//  INIT
// ============================================================
drawLinear();
draw3D();

// Initialize hidden panels on first visit
setTimeout(() => {
  drawAffine();
  drawEigen();
  drawCompose();
  drawFourier();
}, 100);
</script>
</body>
</html>
