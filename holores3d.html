<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio Package | Polarization 3D Rendering</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Oswald:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #000000;
            --secondary: #333333;
            --accent: #ffffff;
            --accent-dark: #cccccc;
            --dark: #121212;
            --darker: #0a0a0a;
            --light: #ffffff;
            --silver: #e0e0e0;
            --gold: #a0a0a0;
            --diamond: #f0f0f0;
            --transition: all 0.4s ease;
            --border: 1px solid rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            color: var(--light);
            overflow-x: hidden;
            line-height: 1.6;
            font-family: 'Montserrat', sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        h1, h2, h3, h4, h5, h6,
        .logo h1,
        nav a,
        .section-title h2,
        .tech-info h3,
        .package-card h3,
        .cta h2,
        .footer-column h3,
        .detail-label,
        .detail-value,
        .package-method,
        .cta-button {
            font-family: 'Oswald', sans-serif;
            letter-spacing: 0.5px;
        }

        .container {
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(15px);
            border: var(--border);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: var(--border);
        }
        
        .logo {
            height: 100px;
            width: auto;
            margin-bottom: 15px;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
        }
        
        h1 {
            font-size: 2.5rem;
            color: var(--light);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .subtitle {
            color: var(--silver);
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .upload-area {
            border: 2px dashed var(--gold);
            background: rgba(45, 55, 72, 0.3);
            padding: 40px 30px;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 12px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        .upload-area:hover {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }
        
        .upload-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: all 0.6s ease;
        }
        
        .upload-area:hover::before {
            left: 100%;
        }
        
        .upload-text {
            font-size: 1.2rem;
            color: var(--silver);
            margin-bottom: 15px;
        }
        
        .upload-icon {
            font-size: 48px;
            color: var(--accent);
            margin-bottom: 15px;
            display: block;
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 12px;
            text-align: center;
            font-weight: 500;
            transition: var(--transition);
        }
        
        .status.processing {
            background: rgba(251, 191, 36, 0.15);
            color: #fcd34d;
            border: 1px solid rgba(251, 191, 36, 0.2);
        }
        
        .status.ready {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.2);
        }
        
        .status.error {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }
        
        .hidden {
            display: none;
        }
        
        .main-display {
            position: relative;
            margin: 30px 0;
            text-align: center;
            background: rgba(15, 18, 32, 0.8);
            padding: 20px;
            border-radius: 16px;
            border: var(--border);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        #outputCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        #outputCanvas:hover {
            transform: scale(1.01);
        }
        
        .controls {
            margin: 30px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }
        
        .control-group {
            background: rgba(45, 55, 72, 0.4);
            backdrop-filter: blur(10px);
            border: var(--border);
            padding: 25px;
            border-radius: 16px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        .control-group:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .control-group::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent), var(--accent-dark));
        }
        
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: var(--light);
            font-size: 1.4rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
        }
        
        .control-group h3 i {
            color: var(--accent);
        }
        
        button {
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: #000000;
            border: none;
            padding: 14px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            font-size: 1rem;
            font-weight: 500;
            transition: var(--transition);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.4);
            position: relative;
            overflow: hidden;
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--accent-dark), var(--accent));
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: -1;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.6);
        }
        
        button:hover::before {
            opacity: 1;
        }
        
        button:disabled {
            background: rgba(74, 85, 104, 0.5);
            color: var(--silver);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        button:disabled:hover::before {
            opacity: 0;
        }
        
        .slider-container {
            margin: 20px 0;
            padding: 20px;
            background: rgba(35, 45, 60, 0.4);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            border: var(--border);
            transition: var(--transition);
        }
        
        .slider-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        label {
            display: block;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1rem;
            color: var(--light);
            position: relative;
            padding-left: 12px;
        }
        
        label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 100%;
            background: linear-gradient(45deg, var(--accent), var(--accent-dark));
            border-radius: 2px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 50px;
            background: linear-gradient(90deg, var(--darker), var(--secondary));
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            transition: var(--transition);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.6);
            transition: var(--transition);
            border: 2px solid white;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.6);
            transition: var(--transition);
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.8);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--silver);
        }
        
        .preview-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: space-between;
        }
        
        .preview-view {
            flex: 1;
            text-align: center;
            background: rgba(35, 45, 60, 0.4);
            padding: 20px;
            border-radius: 16px;
            border: var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .preview-view h4 {
            margin-bottom: 15px;
            color: var(--light);
            font-weight: 600;
            width: 100%;
        }
        
        .preview-view canvas {
            max-width: 100%;
            max-height: 200px;
            width: auto;
            height: auto;
            border-radius: 8px;
            background: #000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            object-fit: contain;
        }
        
        /* Ensure all preview canvases have consistent sizing */
        #leftPreview, #rightPreview, #depthPreview {
            width: 100%;
            height: 150px;
        }
        
        .video-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 20px 0;
            background: rgba(35, 45, 60, 0.4);
            padding: 15px;
            border-radius: 12px;
            border: var(--border);
        }
        
        .video-controls button {
            width: auto;
            padding: 12px 20px;
            margin: 0;
            flex: none;
        }
        
        .progress-container {
            flex: 1;
            margin: 0 15px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(74, 85, 104, 0.6);
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-dark));
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s;
        }
        
        .time-display {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.8rem;
            color: var(--silver);
            background: rgba(35, 45, 60, 0.4);
            border-radius: 8px;
            border: var(--border);
            min-width: 120px;
            text-align: center;
            padding: 5px 10px;
        }
        
        .view-selector {
            display: flex;
            gap: 8px;
            margin: 15px 0;
        }
        
        .view-selector button {
            flex: 1;
            padding: 10px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        .view-selector button:hover {
            background: #000;
            color: #fff;
        }
        
        .export-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .export-mp4 {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .export-zip {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .progress-export {
            width: 100%;
            height: 24px;
            background: rgba(74, 85, 104, 0.4);
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0;
            border: var(--border);
        }
        
        .progress-export-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #10b981);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000000;
            font-size: 13px;
            font-weight: 600;
        }
        
        .feature-badge {
            position: absolute;
            top: -10px;
            right: 15px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
        }
        
        /* Enhanced Fullscreen Overlay */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .fullscreen-canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .fullscreen-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .fullscreen-overlay:hover .fullscreen-controls {
            opacity: 1;
        }
        
        .fullscreen-controls button {
            width: auto;
            margin: 0;
            padding: 12px 20px;
        }
        
        .close-fullscreen {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .fullscreen-overlay:hover .close-fullscreen {
            opacity: 1;
        }
        
        .mirror-btn {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
        }
        
        .share-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }
        
        /* Screen sharing info */
        .sharing-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            display: none;
            z-index: 10001;
        }
        
        /* Instructions Panel */
        .instructions {
            background: rgba(45, 55, 72, 0.6);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0 15px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .instructions::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
            z-index: -1;
        }
        
        .instructions h3 {
            color: var(--accent);
            margin-bottom: 20px;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .instructions h3 i {
            font-size: 1.3em;
        }
        
        .instructions ol {
            padding-left: 30px;
            margin: 20px 0;
            counter-reset: step-counter;
        }
        
        .instructions li {
            margin-bottom: 20px;
            line-height: 1.6;
            position: relative;
            padding-left: 45px;
            font-size: 1.05rem;
        }
        
        .instructions li:before {
            counter-increment: step-counter;
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: #000000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .instructions code {
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            display: inline-block;
            margin: 8px 0;
            color: #f0e68c;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .instructions .note {
            background: rgba(251, 191, 36, 0.15);
            border-left: 4px solid #fcd34d;
            padding: 12px 15px;
            border-radius: 0 8px 8px 0;
            margin: 15px 0;
        }
        
        .instructions .platform {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            align-items: center;
            font-weight: 500;
        }
        
        .instructions .platform i {
            font-size: 1.2em;
        }
        
        .close-instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: transparent;
            border: none;
            color: var(--silver);
            font-size: 1.5rem;
            cursor: pointer;
            width: auto;
            padding: 0;
        }
        
        .close-instructions:hover {
            color: white;
            transform: scale(1.1);
        }
        
        .polarization-info {
            background: rgba(0, 112, 255, 0.1);
            border: 1px solid rgba(0, 112, 255, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .polarization-info i {
            font-size: 24px;
            color: var(--accent);
        }
        
        .polarization-info p {
            flex: 1;
        }
        
        .polarization-glasses {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .glass {
            width: 100px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000000;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .vertical-glass {
            background: linear-gradient(135deg, #ffffff, #cccccc);
        }
        
        .horizontal-glass {
            background: linear-gradient(135deg, #eeeeee, #aaaaaa);
        }
        
        .method-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .method-btn {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: rgba(74, 85, 104, 0.4);
            color: var(--light);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .method-btn.active {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
        }
        
        .method-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .method-description {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9rem;
            border-left: 3px solid var(--accent);
        }
        
        .algorithm-info {
            background: rgba(0, 112, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid var(--accent);
        }
        
        .algorithm-info h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }
        
        .visualization-container {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: rgba(15, 18, 32, 0.8);
            border-radius: 16px;
            border: var(--border);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        }
        
        .visualization-container h3 {
            margin-bottom: 15px;
            color: var(--light);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        #visualizationCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }
        
        .resolution-selector {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .resolution-btn {
            flex: 1;
            min-width: 100px;
            padding: 10px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: rgba(74, 85, 104, 0.4);
            color: var(--light);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .resolution-btn.active {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
        }
        
        .resolution-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .ml-status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .api-controls {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .api-controls h4 {
            color: #8b5cf6;
            margin-bottom: 10px;
        }
        
        /* New styles for enhanced depth processing */
        .depth-visualization {
            background: rgba(15, 18, 32, 0.8);
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            border: var(--border);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        }
        
        .depth-visualization h3 {
            margin-bottom: 15px;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .depth-map-display {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .depth-map-view {
            flex: 1;
            min-width: 200px;
            text-align: center;
            background: rgba(35, 45, 60, 0.4);
            padding: 15px;
            border-radius: 12px;
            border: var(--border);
        }
        
        .depth-map-view h4 {
            margin-bottom: 10px;
            color: var(--light);
            font-size: 0.9rem;
        }
        
        .depth-map-view canvas {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            background: #000;
        }
        
        .convergence-indicator {
            height: 4px;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            margin: 10px 0;
            border-radius: 2px;
            position: relative;
        }
        
        .convergence-marker {
            position: absolute;
            top: -6px;
            width: 3px;
            height: 16px;
            background: white;
            transform: translateX(-50%);
        }
        
        .depth-histogram {
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .histogram-bar {
            position: absolute;
            bottom: 0;
            background: var(--accent);
            width: 2px;
        }
        
        /* FIXED: Dropdown styles with proper z-index hierarchy */
        .dropdown-section {
            margin-bottom: 15px;
            border-radius: 12px;
            overflow: visible; /* Changed from hidden */
            border: var(--border);
            background: rgba(45, 55, 72, 0.4);
            position: relative; /* Added for proper z-index context */
            z-index: 1; /* Base z-index */
        }
        
        .dropdown-section.active {
            z-index: 100; /* Higher z-index when active */
        }
        
        .dropdown-header {
            padding: 18px 25px;
            background: rgba(35, 45, 60, 0.6);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
            position: relative;
            z-index: 10; /* Ensure header stays above content */
        }
        
        .dropdown-header:hover {
            background: rgba(35, 45, 60, 0.8);
        }
        
        .dropdown-header h3 {
            margin: 0;
            font-size: 1.3rem;
            color: var(--light);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .dropdown-header i {
            color: var(--accent);
            font-size: 1.2rem;
        }
        
        .dropdown-arrow {
            transition: transform 0.3s ease;
            color: var(--silver);
        }
        
        .dropdown-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s ease;
            position: relative;
            z-index: 5; /* Lower than header but still above base */
        }
        
        .dropdown-section.active .dropdown-content {
            padding: 25px;
            max-height: 2000px;
            overflow: visible; /* Changed from hidden */
        }
        
        .dropdown-section.active .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        /* FIXED: Tooltip styles with high z-index */
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 8px;
            z-index: 1000; /* Very high z-index to ensure visibility */
        }
        
        .tooltip .tooltip-icon {
            color: var(--silver);
            font-size: 0.9rem;
            cursor: help;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 250px;
            background: rgba(0, 0, 0, 0.9); /* Slightly darker for better contrast */
            color: var(--light);
            text-align: center;
            border-radius: 6px;
            padding: 12px;
            position: absolute;
            z-index: 10000; /* Extremely high z-index */
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none; /* Prevent tooltip from interfering with other elements */
        }
        
        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        .format-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .format-btn {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: rgba(74, 85, 104, 0.4);
            color: var(--light);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .format-btn.active {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
        }
        
        .format-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* View indicators */
        .view-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: none;
        }
        
        .sbs-indicator-left {
            top: 10px;
            left: 10px;
        }
        
        .sbs-indicator-right {
            top: 10px;
            right: 10px;
        }
        
        .tb-indicator-top {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .tb-indicator-bottom {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .preview-container {
                flex-direction: column;
            }
            
            .container {
                padding: 15px;
            }
            
            .instructions li {
                padding-left: 40px;
            }
            
            .method-btn {
                min-width: 100px;
            }
            
            .depth-map-display {
                flex-direction: column;
            }
            
            .fullscreen-controls {
                flex-wrap: wrap;
                justify-content: center;
                width: 90%;
            }
            
            .dropdown-header {
                padding: 15px 20px;
            }
            
            .dropdown-section.active .dropdown-content {
                padding: 20px;
            }
            
            /* Mobile tooltip adjustments */
            .tooltip .tooltip-text {
                width: 200px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .format-btn {
                min-width: 100px;
            }
        }
        
        .fullscreen-btn {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="//c95953e936ea93a4ea36bc48180a0f39.cdn.bubble.io/f1750780466922x524140529408189760/H%20o%20l%20o%20R%20e%20s%20%20Logo%20%28white%29.svg" alt="Studio Package Logo" class="logo">
            <h1>Studio Package</h1>
            <p class="subtitle">Polarization 3D Rendering with Advanced Depth Processing</p>
        </header>
        
        <div class="instructions">
            <button class="close-instructions" onclick="this.parentElement.style.display='none'">×</button>
            <h3><i class="fas fa-info-circle"></i> Polarization 3D Rendering</h3>
            <p>This tool creates polarization 3D content compatible with passive 3D displays and polarized glasses.</p>
            
            <div class="algorithm-info">
                <h4><i class="fas fa-robot"></i> Enhanced Depth Processing</h4>
                <p>Features advanced convergence control, depth range adjustment, and real-time depth analysis for optimal 3D effect.</p>
            </div>
            
            <div class="polarization-info">
                <i class="fas fa-glasses"></i>
                <p>Polarization 3D requires passive polarized glasses to view the 3D effect. Each eye sees a different polarization, creating the 3D illusion on compatible displays.</p>
            </div>
            
            <div class="polarization-glasses">
                <div class="glass vertical-glass">VERTICAL</div>
                <div class="glass horizontal-glass">HORIZONTAL</div>
            </div>
            
            <div class="ml-status" id="mlStatus">
                <i class="fas fa-check-circle"></i> Enhanced Depth Processing Ready
            </div>
        </div>
        
        <div class="upload-area" id="dropZone">
            <span class="upload-icon"><i class="fas fa-cloud-upload-alt"></i></span>
            <p class="upload-text">Drop an MP4 video here or click to upload</p>
            <input type="file" id="fileInput" accept="video/mp4,video/webm,video/ogg" style="display: none;">
        </div>

        <div id="status" class="status hidden">Processing video...</div>

        <div class="preview-container">
            <div class="preview-view">
                <h4><i class="fas fa-eye"></i> Left Eye View</h4>
                <canvas id="leftPreview" width="200" height="150"></canvas>
            </div>
            <div class="preview-view">
                <h4><i class="fas fa-eye"></i> Right Eye View</h4>
                <canvas id="rightPreview" width="200" height="150"></canvas>
            </div>
            <div class="preview-view">
                <h4><i class="fas fa-layer-group"></i> Depth Map</h4>
                <canvas id="depthPreview" width="200" height="150"></canvas>
            </div>
        </div>

        <div class="main-display">
            <canvas id="outputCanvas" width="800" height="450"></canvas>
            <button id="fullscreenBtn" class="fullscreen-btn"><i class="fas fa-expand"></i> Enter Fullscreen 3D Mode</button>
            <button id="shareScreenBtn" class="share-btn" style="margin-top: 10px; display: none;"><i class="fas fa-share-alt"></i> Share Screen</button>
        </div>
        
        <div class="controls">
            <!-- Video Controls Dropdown -->
            <div class="dropdown-section active">
                <div class="dropdown-header">
                    <h3><i class="fas fa-play-circle"></i> Video Controls
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Control video playback, speed, and timeline navigation</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="video-controls">
                        <button id="playPauseBtn" disabled><i class="fas fa-play"></i> Play</button>
                        <button id="stopBtn" disabled><i class="fas fa-stop"></i> Stop</button>
                        <div class="progress-container">
                            <div class="progress-bar" id="progressBar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                        </div>
                        <div class="time-display" id="timeDisplay">00:00 / 00:00</div>
                    </div>
                    <div class="slider-container">
                        <label for="frameRate"><i class="fas fa-tachometer-alt"></i> Playback Speed
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Adjust the playback speed from 0.25x to 2x normal speed</span>
                            </span>
                        </label>
                        <input type="range" id="frameRate" min="0.25" max="2" step="0.05" value="1">
                        <div class="value-display">
                            <span>0.25x</span>
                            <span id="frameRateValue">1.00x</span>
                            <span>2.00x</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- View Controls Dropdown -->
            <div class="dropdown-section active">
                <div class="dropdown-header">
                    <h3><i class="fas fa-sliders-h"></i> View Controls
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Switch between different viewing modes and export individual frames</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="view-selector">
                        <button id="viewLeft"><i class="fas fa-eye"></i> Left</button>
                        <button id="viewRight"><i class="fas fa-eye"></i> Right</button>
                        <button id="viewSideBySide"><i class="fas fa-columns"></i> Side-by-Side</button>
                        <button id="viewTopBottom"><i class="fas fa-grip-lines"></i> Top-Bottom</button>
                        <button id="viewDepth"><i class="fas fa-layer-group"></i> Depth</button>
                    </div>
                    <button id="exportFrame" disabled><i class="fas fa-download"></i> Export Current Frame</button>
                </div>
            </div>
            
            <!-- Polarization Format Dropdown -->
            <div class="dropdown-section">
                <div class="dropdown-header">
                    <h3><i class="fas fa-film"></i> Polarization Format
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Choose the output format for polarization 3D displays</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="slider-container">
                        <label><i class="fas fa-cube"></i> Output Format
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Select the polarization format for 3D displays</span>
                            </span>
                        </label>
                        <div class="format-selector">
                            <div class="format-btn active" data-format="side-by-side">Side-by-Side</div>
                            <div class="format-btn" data-format="top-bottom">Top-Bottom</div>
                            <div class="format-btn" data-format="interlaced">Interlaced</div>
                            <div class="format-btn" data-format="checkerboard">Checkerboard</div>
                        </div>
                        <div class="method-description" id="formatDescription">
                            <strong>Side-by-Side:</strong> Left and right images placed horizontally side by side
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="separation"><i class="fas fa-arrows-h"></i> View Separation
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Adjust the distance between left and right eye views. Higher values create stronger 3D effect but may cause eye strain</span>
                            </span>
                        </label>
                        <input type="range" id="separation" min="0.1" max="100" step="0.1" value="15">
                        <div class="value-display">
                            <span>0.1px</span>
                            <span id="separationValue">15.0px</span>
                            <span>100.0px</span>
                        </div>
                    </div>
                    <div class="slider-container">
                        <label for="depth"><i class="fas fa-layer-group"></i> 3D Depth
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Control the overall depth intensity. Higher values exaggerate the 3D effect</span>
                            </span>
                        </label>
                        <input type="range" id="depth" min="0.1" max="3" step="0.1" value="1">
                        <div class="value-display">
                            <span>0.1</span>
                            <span id="depthValue">1.0</span>
                            <span>3.0</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Convergence & Depth Control Dropdown -->
            <div class="dropdown-section">
                <div class="dropdown-header">
                    <h3><i class="fas fa-crosshairs"></i> Convergence & Depth Control
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Advanced controls for fine-tuning the 3D convergence point and depth mapping behavior</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="slider-container">
                        <label for="convergence"><i class="fas fa-bullseye"></i> Convergence Plane
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Set the convergence point where objects appear at screen depth. Objects in front will pop out, objects behind will recede</span>
                            </span>
                        </label>
                        <input type="range" id="convergence" min="0" max="1" step="0.01" value="0.5">
                        <div class="value-display">
                            <span>Background</span>
                            <span id="convergenceValue">0.50</span>
                            <span>Foreground</span>
                        </div>
                        <div class="convergence-indicator">
                            <div class="convergence-marker" id="convergenceMarker" style="left: 50%;"></div>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="depthRange"><i class="fas fa-arrows-alt-v"></i> Depth Range
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Control the overall depth range. Higher values create more dramatic 3D effects</span>
                            </span>
                        </label>
                        <input type="range" id="depthRange" min="0.1" max="2" step="0.1" value="1">
                        <div class="value-display">
                            <span>Narrow</span>
                            <span id="depthRangeValue">1.0</span>
                            <span>Wide</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="depthCurve"><i class="fas fa-chart-line"></i> Depth Curve
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Adjust the depth response curve. Lower values emphasize near objects, higher values emphasize distant objects</span>
                            </span>
                        </label>
                        <input type="range" id="depthCurve" min="0.1" max="3" step="0.1" value="1">
                        <div class="value-display">
                            <span>Linear</span>
                            <span id="depthCurveValue">1.0</span>
                            <span>Exponential</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label for="autoConvergence"><i class="fas fa-robot"></i> Auto Convergence
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Automatically adjust convergence based on scene content. 0% is manual, 100% is fully automatic</span>
                            </span>
                        </label>
                        <input type="range" id="autoConvergence" min="0" max="100" step="1" value="0">
                        <div class="value-display">
                            <span>Manual</span>
                            <span id="autoConvergenceValue">0%</span>
                            <span>Full Auto</span>
                        </div>
                    </div>
                    
                    <!-- Depth Inversion Button -->
                    <div class="slider-container">
                        <label><i class="fas fa-exchange-alt"></i> Depth Map Inversion
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Toggle if the 3D effect appears reversed (pop-out vs pop-in)</span>
                            </span>
                        </label>
                        <div class="method-selector">
                            <div class="method-btn active" id="invertDepthOff">Normal Depth</div>
                            <div class="method-btn" id="invertDepthOn">Inverted Depth</div>
                        </div>
                        <div class="method-description">
                            <strong>Inversion Control:</strong> Toggle if the 3D effect appears reversed (pop-out vs pop-in)
                        </div>
                    </div>
                    
                    <button id="analyzeDepth"><i class="fas fa-chart-bar"></i> Analyze Depth Scene</button>
                </div>
            </div>

            <!-- Depth Analysis Dropdown -->
            <div class="dropdown-section">
                <div class="dropdown-header">
                    <h3><i class="fas fa-map"></i> Depth Analysis
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Visualize and analyze depth information with real-time statistics and histograms</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="depth-visualization">
                        <h3><i class="fas fa-wave-square"></i> Depth Map Visualization</h3>
                        <div class="depth-map-display">
                            <div class="depth-map-view">
                                <h4>Raw Depth</h4>
                                <canvas id="rawDepthViz" width="150" height="100"></canvas>
                            </div>
                            <div class="depth-map-view">
                                <h4>Processed</h4>
                                <canvas id="processedDepthViz" width="150" height="100"></canvas>
                            </div>
                            <div class="depth-map-view">
                                <h4>Displacement</h4>
                                <canvas id="displacementViz" width="150" height="100"></canvas>
                            </div>
                        </div>
                        
                        <div class="depth-histogram" id="depthHistogram">
                            <!-- Histogram bars will be generated dynamically -->
                        </div>
                        
                        <div class="depth-stats">
                            <div class="value-display">
                                <span>Min Depth: <span id="minDepth">0.00</span></span>
                                <span>Max Depth: <span id="maxDepth">1.00</span></span>
                                <span>Avg Depth: <span id="avgDepth">0.50</span></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Depth Settings Dropdown -->
            <div class="dropdown-section">
                <div class="dropdown-header">
                    <h3><i class="fas fa-brain"></i> Depth Settings
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Configure depth map generation parameters for optimal 3D effect</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="slider-container">
                        <label for="depthMapStrength"><i class="fas fa-sliders-h"></i> Depth Map Strength
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Control the intensity of the depth effect. Higher values create more pronounced 3D separation</span>
                            </span>
                        </label>
                        <input type="range" id="depthMapStrength" min="0" max="2" step="0.1" value="1">
                        <div class="value-display">
                            <span>0.0</span>
                            <span id="depthMapStrengthValue">1.0</span>
                            <span>2.0</span>
                        </div>
                    </div>
                    <div class="slider-container">
                        <label for="depthSmoothing"><i class="fas fa-wind"></i> Depth Smoothing
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Smooth the depth map to reduce noise and artifacts. Higher values create smoother transitions</span>
                            </span>
                        </label>
                        <input type="range" id="depthSmoothing" min="0" max="10" step="1" value="3">
                        <div class="value-display">
                            <span>0</span>
                            <span id="depthSmoothingValue">3</span>
                            <span>10</span>
                        </div>
                    </div>
                    <div class="slider-container">
                        <label for="depthThreshold"><i class="fas fa-filter"></i> Depth Threshold
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Set the minimum depth value. Lower values include more subtle depth variations</span>
                            </span>
                        </label>
                        <input type="range" id="depthThreshold" min="0" max="1" step="0.05" value="0.5">
                        <div class="value-display">
                            <span>0.0</span>
                            <span id="depthThresholdValue">0.5</span>
                            <span>1.0</span>
                        </div>
                    </div>
                    <div class="method-selector">
                        <div class="method-btn active" data-depth-mode="api">Enhanced Depth</div>
                        <div class="method-btn" data-depth-mode="luminance">Luminance</div>
                        <div class="method-btn" data-depth-mode="edges">Edge-based</div>
                    </div>
                    <div class="method-description">
                        <strong>Enhanced Depth:</strong> Uses advanced depth estimation with convergence control
                    </div>
                </div>
            </div>

            <!-- Export Options Dropdown -->
            <div class="dropdown-section">
                <div class="dropdown-header">
                    <h3><i class="fas fa-file-export"></i> Export Options
                        <span class="tooltip">
                            <i class="fas fa-info-circle tooltip-icon"></i>
                            <span class="tooltip-text">Export your 3D video in various formats and resolutions</span>
                        </span>
                    </h3>
                    <i class="fas fa-chevron-down dropdown-arrow"></i>
                </div>
                <div class="dropdown-content">
                    <div class="slider-container">
                        <label><i class="fas fa-expand"></i> Export Resolution
                            <span class="tooltip">
                                <i class="fas fa-info-circle tooltip-icon"></i>
                                <span class="tooltip-text">Choose the output resolution for your exported video. Higher resolutions take longer to process</span>
                            </span>
                        </label>
                        <div class="resolution-selector">
                            <div class="resolution-btn active" data-res="original">Original</div>
                            <div class="resolution-btn" data-res="720">HD (720p)</div>
                            <div class="resolution-btn" data-res="1080">Full HD (1080p)</div>
                            <div class="resolution-btn" data-res="2160">4K (2160p)</div>
                        </div>
                        <div class="note">High resolutions may take longer to process</div>
                    </div>
                    
                    <div class="export-buttons">
                        <button id="exportMP4" class="export-mp4" disabled><i class="fas fa-file-video"></i> Export as MP4</button>
                        <button id="exportZip" class="export-zip" disabled><i class="fas fa-file-archive"></i> Export as ZIP</button>
                    </div>
                    <div id="exportProgress" class="progress-export hidden">
                        <div id="exportProgressFill" class="progress-export-fill">0%</div>
                    </div>
                    <div id="exportStatus" class="status hidden">Exporting frames...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Fullscreen Overlay -->
    <div class="fullscreen-overlay" id="fullscreenOverlay">
        <div class="sharing-info" id="sharingInfo">
            <i class="fas fa-info-circle"></i> Screen sharing active
        </div>
        <button class="close-fullscreen" id="closeFullscreen">
            <i class="fas fa-times"></i>
        </button>
        <canvas class="fullscreen-canvas" id="fullscreenCanvas"></canvas>
        <div class="fullscreen-controls">
            <button id="fsPlayPause"><i class="fas fa-pause"></i> Pause</button>
            <button id="fsMirror" class="mirror-btn"><i class="fas fa-sync-alt"></i> Mirror Display</button>
            <button id="fsShare" class="share-btn"><i class="fas fa-share-alt"></i> Share Screen</button>
            <button id="fsExit"><i class="fas fa-compress"></i> Exit Fullscreen</button>
        </div>
    </div>

   <script>
   class Polarization3DRenderer {
        constructor() {
            this.depthMode = 'api';
            // Enhanced depth processing properties
            this.convergence = 0.5;
            this.depthRange = 1.0;
            this.depthCurve = 1.0;
            this.autoConvergence = 0;
            this.depthStats = {
                min: 0,
                max: 1,
                avg: 0.5,
                histogram: new Array(20).fill(0)
            };
            
            // Depth inversion property
            this.invertDepth = false;
            
            // Polarization format
            this.polarizationFormat = 'side-by-side';
            
            // Screen sharing properties
            this.screenStream = null;
            this.screenVideo = null;
            this.isSharingScreen = false;
            
            this.setupDOM();
            this.setupEventListeners();
            this.initializeSettings();
            this.setupCanvas();
            this.initializeDepthAPI();
            this.setupDropdowns();
        }

        setupDropdowns() {
            const dropdownHeaders = document.querySelectorAll('.dropdown-header');
            dropdownHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const section = header.parentElement;
                    section.classList.toggle('active');
                });
            });
        }

        initializeDepthAPI() {
            this.depthAPIReady = true;
            this.isProcessingDepth = false;
            this.depthQueue = [];
            this.maxConcurrentRequests = 2;
            this.currentRequests = 0;
            
            const mlStatus = document.getElementById('mlStatus');
            mlStatus.innerHTML = '<i class="fas fa-check-circle"></i> Enhanced Depth Processing Ready';
            mlStatus.style.background = 'rgba(34, 197, 94, 0.1)';
            mlStatus.style.border = '1px solid rgba(34, 197, 94, 0.3)';
        }

        setupDOM() {
            this.dropZone = document.getElementById('dropZone');
            this.fileInput = document.getElementById('fileInput');
            this.status = document.getElementById('status');
            this.outputCanvas = document.getElementById('outputCanvas');
            this.leftPreview = document.getElementById('leftPreview');
            this.rightPreview = document.getElementById('rightPreview');
            this.depthPreview = document.getElementById('depthPreview');
            
            // Video controls
            this.playPauseBtn = document.getElementById('playPauseBtn');
            this.stopBtn = document.getElementById('stopBtn');
            this.progressBar = document.getElementById('progressBar');
            this.progressFill = document.getElementById('progressFill');
            this.timeDisplay = document.getElementById('timeDisplay');
            this.frameRateSlider = document.getElementById('frameRate');
            this.frameRateValue = document.getElementById('frameRateValue');
            
            // 3D controls
            this.separationSlider = document.getElementById('separation');
            this.separationValue = document.getElementById('separationValue');
            this.depthSlider = document.getElementById('depth');
            this.depthValue = document.getElementById('depthValue');
            this.exportFrameBtn = document.getElementById('exportFrame');
            this.formatButtons = document.querySelectorAll('.format-btn');
            this.formatDescription = document.getElementById('formatDescription');
            this.resolutionButtons = document.querySelectorAll('.resolution-btn');
            
            // Depth inversion buttons
            this.invertDepthOff = document.getElementById('invertDepthOff');
            this.invertDepthOn = document.getElementById('invertDepthOn');
            
            // Depth map controls
            this.depthMapStrengthSlider = document.getElementById('depthMapStrength');
            this.depthMapStrengthValue = document.getElementById('depthMapStrengthValue');
            this.depthSmoothingSlider = document.getElementById('depthSmoothing');
            this.depthSmoothingValue = document.getElementById('depthSmoothingValue');
            this.depthThresholdSlider = document.getElementById('depthThreshold');
            this.depthThresholdValue = document.getElementById('depthThresholdValue');
            this.depthModeButtons = document.querySelectorAll('[data-depth-mode]');
            
            // View controls
            this.viewButtons = {
                left: document.getElementById('viewLeft'),
                right: document.getElementById('viewRight'),
                sideBySide: document.getElementById('viewSideBySide'),
                topBottom: document.getElementById('viewTopBottom'),
                depth: document.getElementById('viewDepth')
            };

            // Export controls
            this.exportMP4Btn = document.getElementById('exportMP4');
            this.exportZipBtn = document.getElementById('exportZip');
            this.exportProgress = document.getElementById('exportProgress');
            this.exportProgressFill = document.getElementById('exportProgressFill');
            this.exportStatus = document.getElementById('exportStatus');
            
            // Fullscreen controls
            this.fullscreenBtn = document.getElementById('fullscreenBtn');
            this.fullscreenOverlay = document.getElementById('fullscreenOverlay');
            this.fullscreenCanvas = document.getElementById('fullscreenCanvas');
            this.closeFullscreen = document.getElementById('closeFullscreen');
            this.fsPlayPause = document.getElementById('fsPlayPause');
            this.fsMirror = document.getElementById('fsMirror');
            this.fsExit = document.getElementById('fsExit');
            
            // Screen sharing elements
            this.shareScreenBtn = document.getElementById('shareScreenBtn');
            this.sharingInfo = document.getElementById('sharingInfo');
            this.fsShare = document.getElementById('fsShare');
            
            // Enhanced depth controls
            this.convergenceSlider = document.getElementById('convergence');
            this.convergenceValue = document.getElementById('convergenceValue');
            this.convergenceMarker = document.getElementById('convergenceMarker');
            
            this.depthRangeSlider = document.getElementById('depthRange');
            this.depthRangeValue = document.getElementById('depthRangeValue');
            
            this.depthCurveSlider = document.getElementById('depthCurve');
            this.depthCurveValue = document.getElementById('depthCurveValue');
            
            this.autoConvergenceSlider = document.getElementById('autoConvergence');
            this.autoConvergenceValue = document.getElementById('autoConvergenceValue');
            
            this.analyzeDepthBtn = document.getElementById('analyzeDepth');
            
            // Visualization elements
            this.rawDepthViz = document.getElementById('rawDepthViz');
            this.processedDepthViz = document.getElementById('processedDepthViz');
            this.displacementViz = document.getElementById('displacementViz');
            this.depthHistogram = document.getElementById('depthHistogram');
            this.minDepth = document.getElementById('minDepth');
            this.maxDepth = document.getElementById('maxDepth');
            this.avgDepth = document.getElementById('avgDepth');
            
            this.rawDepthCtx = this.rawDepthViz.getContext('2d');
            this.processedDepthCtx = this.processedDepthViz.getContext('2d');
            this.displacementCtx = this.displacementViz.getContext('2d');
        }

        initializeSettings() {
            this.video = null;
            this.isPlaying = false;
            this.currentView = 'sideBySide';
            this.separation = 15;
            this.depth = 1.0;
            this.playbackRate = 1.0;
            this.animationFrame = null;
            this.isExporting = false;
            this.exportResolution = 'original';
            
            // Depth map settings
            this.depthMapStrength = 1.0;
            this.depthSmoothing = 3;
            this.depthThreshold = 0.5;
            this.depthMap = null;
            
            // Depth inversion setting
            this.invertDepth = false;
            
            // Fullscreen settings
            this.isFullscreen = false;
            this.isMirrored = false;
            
            // Screen sharing settings
            this.isSharingScreen = false;
            
            // Format descriptions
            this.formatDescriptions = {
                "side-by-side": "Side-by-Side: Left and right images placed horizontally side by side",
                "top-bottom": "Top-Bottom: Left image on top, right image on bottom",
                "interlaced": "Interlaced: Alternating lines for left and right eyes",
                "checkerboard": "Checkerboard: Checkerboard pattern for left and right eyes"
            };
        }

        setupCanvas() {
            this.ctx = this.outputCanvas.getContext('2d');
            this.leftCtx = this.leftPreview.getContext('2d');
            this.rightCtx = this.rightPreview.getContext('2d');
            this.depthCtx = this.depthPreview.getContext('2d');
            this.fsCtx = this.fullscreenCanvas.getContext('2d');
            
            // Create hidden canvases for processing
            this.leftCanvas = document.createElement('canvas');
            this.rightCanvas = document.createElement('canvas');
            this.depthCanvas = document.createElement('canvas');
            this.leftCanvasCtx = this.leftCanvas.getContext('2d');
            this.rightCanvasCtx = this.rightCanvas.getContext('2d');
            this.depthCanvasCtx = this.depthCanvas.getContext('2d');
            
            // Create a temporary canvas for processing
            this.tempCanvas = document.createElement('canvas');
            this.tempCtx = this.tempCanvas.getContext('2d');
        }

        setupEventListeners() {
            // File upload
            this.dropZone.addEventListener('click', () => this.fileInput.click());
            this.dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                this.dropZone.style.background = 'rgba(255, 255, 255, 0.2)';
            });
            this.dropZone.addEventListener('dragleave', () => {
                this.dropZone.style.background = 'rgba(45, 55, 72, 0.3)';
            });
            this.dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                this.dropZone.style.background = 'rgba(45, 55, 72, 0.3)';
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    this.handleVideo(file);
                }
            });
            this.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) this.handleVideo(file);
            });

            // Video controls
            this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
            this.stopBtn.addEventListener('click', () => this.stopVideo());
            this.progressBar.addEventListener('click', (e) => this.seekVideo(e));
            
            this.frameRateSlider.addEventListener('input', () => {
                this.playbackRate = parseFloat(this.frameRateSlider.value);
                this.frameRateValue.textContent = this.playbackRate.toFixed(2) + 'x';
                if (this.video) this.video.playbackRate = this.playbackRate;
            });

            // 3D controls
            this.separationSlider.addEventListener('input', () => {
                this.separation = parseFloat(this.separationSlider.value);
                this.separationValue.textContent = this.separation.toFixed(1) + 'px';
                this.renderCurrentFrame();
            });

            this.depthSlider.addEventListener('input', () => {
                this.depth = parseFloat(this.depthSlider.value);
                this.depthValue.textContent = this.depth.toFixed(1);
                this.renderCurrentFrame();
            });

            this.exportFrameBtn.addEventListener('click', () => this.exportCurrentFrame());

            // View controls
            Object.entries(this.viewButtons).forEach(([view, button]) => {
                button.addEventListener('click', () => this.setView(view));
            });

            // Export controls
            this.exportMP4Btn.addEventListener('click', () => this.exportAsMP4());
            this.exportZipBtn.addEventListener('click', () => this.exportAsZip());
            
            // Format selection
            this.formatButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    this.formatButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.polarizationFormat = btn.dataset.format;
                    this.formatDescription.textContent = this.formatDescriptions[this.polarizationFormat];
                    this.renderCurrentFrame();
                });
            });
            
            // Depth inversion controls
            this.invertDepthOff.addEventListener('click', () => {
                this.setDepthInversion(false);
            });
            
            this.invertDepthOn.addEventListener('click', () => {
                this.setDepthInversion(true);
            });
            
            // Resolution selection
            this.resolutionButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    this.resolutionButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.exportResolution = btn.dataset.res;
                });
            });
            
            // Depth map controls
            this.depthMapStrengthSlider.addEventListener('input', () => {
                this.depthMapStrength = parseFloat(this.depthMapStrengthSlider.value);
                this.depthMapStrengthValue.textContent = this.depthMapStrength.toFixed(1);
                this.renderCurrentFrame();
            });
            
            this.depthSmoothingSlider.addEventListener('input', () => {
                this.depthSmoothing = parseInt(this.depthSmoothingSlider.value);
                this.depthSmoothingValue.textContent = this.depthSmoothing;
                this.renderCurrentFrame();
            });
            
            this.depthThresholdSlider.addEventListener('input', () => {
                this.depthThreshold = parseFloat(this.depthThresholdSlider.value);
                this.depthThresholdValue.textContent = this.depthThreshold.toFixed(2);
                this.renderCurrentFrame();
            });
            
            // Depth mode selection
            this.depthModeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    this.depthModeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.depthMode = btn.dataset.depthMode;
                    this.renderCurrentFrame();
                });
            });
            
            // Fullscreen controls
            this.fullscreenBtn.addEventListener('click', () => this.enterFullscreen());
            this.outputCanvas.addEventListener('click', () => this.enterFullscreen());
            this.closeFullscreen.addEventListener('click', () => this.exitFullscreen());
            this.fsPlayPause.addEventListener('click', () => this.togglePlayPause());
            this.fsMirror.addEventListener('click', () => this.toggleMirror());
            this.fsExit.addEventListener('click', () => this.exitFullscreen());
            
            // Screen sharing controls
            this.shareScreenBtn.addEventListener('click', () => this.startScreenSharing());
            this.fsShare.addEventListener('click', () => this.startScreenSharing());
            
            // Handle screen sharing stop
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement && this.isSharingScreen) {
                    this.stopScreenSharing();
                }
            });
            
            // Enhanced depth controls
            this.convergenceSlider.addEventListener('input', () => {
                this.convergence = parseFloat(this.convergenceSlider.value);
                this.convergenceValue.textContent = this.convergence.toFixed(2);
                this.convergenceMarker.style.left = (this.convergence * 100) + '%';
                this.renderCurrentFrame();
            });

            this.depthRangeSlider.addEventListener('input', () => {
                this.depthRange = parseFloat(this.depthRangeSlider.value);
                this.depthRangeValue.textContent = this.depthRange.toFixed(1);
                this.renderCurrentFrame();
            });

            this.depthCurveSlider.addEventListener('input', () => {
                this.depthCurve = parseFloat(this.depthCurveSlider.value);
                this.depthCurveValue.textContent = this.depthCurve.toFixed(1);
                this.renderCurrentFrame();
            });

            this.autoConvergenceSlider.addEventListener('input', () => {
                this.autoConvergence = parseInt(this.autoConvergenceSlider.value);
                this.autoConvergenceValue.textContent = this.autoConvergence + '%';
                this.renderCurrentFrame();
            });

            this.analyzeDepthBtn.addEventListener('click', () => {
                this.analyzeDepthScene();
            });
            
            // Handle ESC key to exit fullscreen
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.isFullscreen) {
                    this.exitFullscreen();
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (this.isFullscreen) {
                    this.updateFullscreenCanvasSize();
                    this.updateFullscreen();
                }
            });
        }

        setDepthInversion(invert) {
            this.invertDepth = invert;
            
            // Update UI
            if (invert) {
                this.invertDepthOff.classList.remove('active');
                this.invertDepthOn.classList.add('active');
            } else {
                this.invertDepthOff.classList.add('active');
                this.invertDepthOn.classList.remove('active');
            }
            
            // Re-render with new inversion setting
            this.renderCurrentFrame();
        }

        showStatus(message, type = 'processing') {
            this.status.textContent = message;
            this.status.className = `status ${type}`;
            this.status.classList.remove('hidden');
        }

        hideStatus() {
            this.status.classList.add('hidden');
        }

        handleVideo(file) {
            this.showStatus('Loading video...', 'processing');
            
            if (this.video) {
                this.video.pause();
                this.video = null;
            }

            this.video = document.createElement('video');
            this.video.crossOrigin = 'anonymous';
            this.video.muted = true;
            this.video.playbackRate = this.playbackRate;

            this.video.addEventListener('loadedmetadata', () => {
                this.setupVideoCanvas();
                this.enableControls();
                this.showStatus('Video loaded successfully!', 'ready');
                setTimeout(() => this.hideStatus(), 2000);
            });

            this.video.addEventListener('timeupdate', () => this.updateProgress());
            this.video.addEventListener('ended', () => this.onVideoEnded());
            this.video.addEventListener('play', () => this.startRendering());
            this.video.addEventListener('pause', () => this.stopRendering());

            const url = URL.createObjectURL(file);
            this.video.src = url;
        }

        setupVideoCanvas() {
            const { videoWidth, videoHeight } = this.video;
            
            // Store original video dimensions
            this.originalVideoWidth = videoWidth;
            this.originalVideoHeight = videoHeight;
            
            // Set main canvas size to match video dimensions
            this.outputCanvas.width = videoWidth;
            this.outputCanvas.height = videoHeight;
            
            // Set processing canvas sizes to match video dimensions
            this.leftCanvas.width = this.rightCanvas.width = this.depthCanvas.width = videoWidth;
            this.leftCanvas.height = this.rightCanvas.height = this.depthCanvas.height = videoHeight;
            this.tempCanvas.width = videoWidth;
            this.tempCanvas.height = videoHeight;
            
            // Set preview canvas sizes with fixed dimensions but maintain aspect ratio
            const previewWidth = 200;
            const previewHeight = 150;
            
            this.leftPreview.width = previewWidth;
            this.leftPreview.height = previewHeight;
            this.rightPreview.width = previewWidth;
            this.rightPreview.height = previewHeight;
            this.depthPreview.width = previewWidth;
            this.depthPreview.height = previewHeight;
            
            // Set visualization canvas sizes
            const vizWidth = 150;
            const vizHeight = 100;
            
            this.rawDepthViz.width = vizWidth;
            this.rawDepthViz.height = vizHeight;
            this.processedDepthViz.width = vizWidth;
            this.processedDepthViz.height = vizHeight;
            this.displacementViz.width = vizWidth;
            this.displacementViz.height = vizHeight;
            
            this.renderCurrentFrame();
        }

        enableControls() {
            this.playPauseBtn.disabled = false;
            this.playPauseBtn.innerHTML = '<i class="fas fa-play"></i> Play';
            this.stopBtn.disabled = false;
            this.exportFrameBtn.disabled = false;
            this.exportMP4Btn.disabled = false;
            this.exportZipBtn.disabled = false;
        }

        togglePlayPause() {
            if (!this.video) return;

            if (this.isPlaying) {
                this.video.pause();
                this.playPauseBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                this.fsPlayPause.innerHTML = '<i class="fas fa-play"></i> Play';
                this.isPlaying = false;
            } else {
                this.video.play();
                this.playPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                this.fsPlayPause.innerHTML = '<i class="fas fa-pause"></i> Pause';
                this.isPlaying = true;
            }
        }

        stopVideo() {
            if (!this.video) return;

            this.video.pause();
            this.video.currentTime = 0;
            this.playPauseBtn.innerHTML = '<i class="fas fa-play"></i> Play';
            this.fsPlayPause.innerHTML = '<i class="fas fa-play"></i> Play';
            this.isPlaying = false;
            this.renderCurrentFrame();
        }

        seekVideo(e) {
            if (!this.video) return;

            const rect = this.progressBar.getBoundingClientRect();
            const progress = (e.clientX - rect.left) / rect.width;
            this.video.currentTime = progress * this.video.duration;
            this.renderCurrentFrame();
        }

        updateProgress() {
            if (!this.video) return;

            const progress = (this.video.currentTime / this.video.duration) * 100;
            this.progressFill.style.width = progress + '%';

            const currentMin = Math.floor(this.video.currentTime / 60);
            const currentSec = Math.floor(this.video.currentTime % 60);
            const totalMin = Math.floor(this.video.duration / 60);
            const totalSec = Math.floor(this.video.duration % 60);

            this.timeDisplay.textContent = 
                `${String(currentMin).padStart(2, '0')}:${String(currentSec).padStart(2, '0')} / ` +
                `${String(totalMin).padStart(2, '0')}:${String(totalSec).padStart(2, '0')}`;
        }

        onVideoEnded() {
            this.isPlaying = false;
            this.playPauseBtn.innerHTML = '<i class="fas fa-play"></i> Play';
            this.fsPlayPause.innerHTML = '<i class="fas fa-play"></i> Play';
            this.stopRendering();
        }

        startRendering() {
            this.stopRendering();
            this.renderLoop();
        }

        stopRendering() {
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
                this.animationFrame = null;
            }
        }

        renderLoop() {
            if (this.video && !this.video.paused) {
                this.renderCurrentFrame();
                this.animationFrame = requestAnimationFrame(() => this.renderLoop());
            }
        }

        async renderCurrentFrame() {
            if (!this.video) return;

            const { width, height } = this.outputCanvas;

            // Clear canvases
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, width, height);
            this.leftCanvasCtx.fillStyle = '#000';
            this.leftCanvasCtx.fillRect(0, 0, width, height);
            this.rightCanvasCtx.fillStyle = '#000';
            this.rightCanvasCtx.fillRect(0, 0, width, height);
            this.depthCanvasCtx.fillStyle = '#000';
            this.depthCanvasCtx.fillRect(0, 0, width, height);

            // Generate depth map
            await this.generateDepthMap(width, height);

            // Render left and right eye views
            this.renderEyeViews(width, height);

            // Render based on current view
            this.renderView();

            // Update preview canvases
            this.updatePreviews();
            
            // Update fullscreen canvas if active
            if (this.isFullscreen) {
                this.updateFullscreen();
            }
        }

        // NEW: Synchronous rendering for export
        renderCurrentFrameSync() {
            if (!this.video) return;

            const { width, height } = this.outputCanvas;

            // Clear canvases
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, width, height);
            this.leftCanvasCtx.fillStyle = '#000';
            this.leftCanvasCtx.fillRect(0, 0, width, height);
            this.rightCanvasCtx.fillStyle = '#000';
            this.rightCanvasCtx.fillRect(0, 0, width, height);
            this.depthCanvasCtx.fillStyle = '#000';
            this.depthCanvasCtx.fillRect(0, 0, width, height);

            // Draw current frame to temp canvas
            this.tempCtx.drawImage(this.video, 0, 0, width, height);

            // Generate depth map synchronously
            this.generateDepthMapSync(width, height);

            // Render left and right eye views
            this.renderEyeViewsSync(width, height);

            // Render based on current view
            this.renderViewSync();

            // Update preview canvases
            this.updatePreviews();
        }

        // NEW: Synchronous depth map generation
        generateDepthMapSync(width, height) {
            if (this.depthMode === 'api') {
                this.generateEnhancedDepthMap(width, height);
            } else {
                this.generateFallbackDepthMap(width, height);
            }
        }

        // NEW: Synchronous eye view rendering
        renderEyeViewsSync(width, height) {
            if (this.depthMode !== 'api' && this.currentDepthMap) {
                this.renderEnhancedEyeViews(width, height);
            } else {
                const baseSeparation = this.separation * this.depth;
                this.renderUniformEyeViews(width, height, baseSeparation);
            }
        }

        // NEW: Synchronous view rendering
        renderViewSync() {
            const { width, height } = this.outputCanvas;

            // Remove any existing view indicators
            const existingIndicators = document.querySelectorAll('.view-indicator');
            existingIndicators.forEach(indicator => indicator.remove());

            switch (this.currentView) {
                case 'left':
                    this.ctx.drawImage(this.leftCanvas, 0, 0, width, height);
                    break;
                case 'right':
                    this.ctx.drawImage(this.rightCanvas, 0, 0, width, height);
                    break;
                case 'sideBySide':
                    this.renderSideBySideSync();
                    break;
                case 'topBottom':
                    this.renderTopBottomSync();
                    break;
                case 'depth':
                    this.ctx.drawImage(this.depthCanvas, 0, 0, width, height);
                    break;
            }
        }

        // NEW: Synchronous side-by-side rendering
        renderSideBySideSync() {
            const { width, height } = this.outputCanvas;
            
            // Clear the output canvas
            this.ctx.clearRect(0, 0, width, height);
            
            // Calculate dimensions for each view
            const viewWidth = width / 2;
            const viewHeight = height;
            
            // Calculate scaling to maintain aspect ratio
            const videoAspect = this.originalVideoWidth / this.originalVideoHeight;
            const viewAspect = viewWidth / viewHeight;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (videoAspect > viewAspect) {
                // Video is wider than view - fit to width
                drawWidth = viewWidth;
                drawHeight = viewWidth / videoAspect;
                offsetX = 0;
                offsetY = (viewHeight - drawHeight) / 2;
            } else {
                // Video is taller than view - fit to height
                drawHeight = viewHeight;
                drawWidth = viewHeight * videoAspect;
                offsetX = (viewWidth - drawWidth) / 2;
                offsetY = 0;
            }
            
            // Draw left and right views with proper aspect ratio
            this.ctx.drawImage(
                this.leftCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                0, offsetY, drawWidth, drawHeight
            );
            
            this.ctx.drawImage(
                this.rightCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                viewWidth, offsetY, drawWidth, drawHeight
            );
            
            // Add view indicators
            this.addViewIndicators('sbs');
        }

        // NEW: Synchronous top-bottom rendering
        renderTopBottomSync() {
            const { width, height } = this.outputCanvas;
            
            // Clear the output canvas
            this.ctx.clearRect(0, 0, width, height);
            
            // Calculate dimensions for each view
            const viewWidth = width;
            const viewHeight = height / 2;
            
            // Calculate scaling to maintain aspect ratio
            const videoAspect = this.originalVideoWidth / this.originalVideoHeight;
            const viewAspect = viewWidth / viewHeight;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (videoAspect > viewAspect) {
                // Video is wider than view - fit to width
                drawWidth = viewWidth;
                drawHeight = viewWidth / videoAspect;
                offsetX = 0;
                offsetY = (viewHeight - drawHeight) / 2;
            } else {
                // Video is taller than view - fit to height
                drawHeight = viewHeight;
                drawWidth = viewHeight * videoAspect;
                offsetX = (viewWidth - drawWidth) / 2;
                offsetY = 0;
            }
            
            // Draw top and bottom views with proper aspect ratio
            this.ctx.drawImage(
                this.leftCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                offsetX, 0, drawWidth, drawHeight
            );
            
            this.ctx.drawImage(
                this.rightCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                offsetX, viewHeight, drawWidth, drawHeight
            );
            
            // Add view indicators
            this.addViewIndicators('tb');
        }

        async generateDepthMap(width, height) {
            // Draw current frame to temp canvas
            this.tempCtx.drawImage(this.video, 0, 0, width, height);
            
            if (this.depthMode === 'api') {
                this.generateEnhancedDepthMap(width, height);
            } else {
                this.generateFallbackDepthMap(width, height);
            }
        }

        generateEnhancedDepthMap(width, height) {
            // Enhanced depth estimation using multiple techniques
            const imageData = this.tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const depthMap = this.depthCanvasCtx.createImageData(width, height);
            
            // Create multiple depth channels
            const luminanceDepth = new Float32Array(width * height);
            const edgeDepth = new Float32Array(width * height);
            const saturationDepth = new Float32Array(width * height);
            
            // Calculate luminance-based depth
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Luminance (darker = farther)
                luminanceDepth[idx] = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                // Saturation (more saturated = closer)
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                saturationDepth[idx] = saturation;
            }
            
            // Calculate edge-based depth
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // Simple Sobel edge detection
                    const gx = (
                        -1 * this.getLuminance(data, x-1, y-1, width) +
                        1 * this.getLuminance(data, x+1, y-1, width) +
                        -2 * this.getLuminance(data, x-1, y, width) +
                        2 * this.getLuminance(data, x+1, y, width) +
                        -1 * this.getLuminance(data, x-1, y+1, width) +
                        1 * this.getLuminance(data, x+1, y+1, width)
                    );
                    
                    const gy = (
                        -1 * this.getLuminance(data, x-1, y-1, width) +
                        -2 * this.getLuminance(data, x, y-1, width) +
                        -1 * this.getLuminance(data, x+1, y-1, width) +
                        1 * this.getLuminance(data, x-1, y+1, width) +
                        2 * this.getLuminance(data, x, y+1, width) +
                        1 * this.getLuminance(data, x+1, y+1, width)
                    );
                    
                    const edgeStrength = Math.sqrt(gx * gx + gy * gy) / 1020;
                    edgeDepth[idx] = edgeStrength;
                }
            }
            
            // Combine depth channels with weights
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                
                let depthValue = (
                    luminanceDepth[idx] * 0.6 +
                    edgeDepth[idx] * 0.3 +
                    saturationDepth[idx] * 0.1
                );
                
                // Apply depth inversion if enabled
                if (this.invertDepth) {
                    depthValue = 1 - depthValue;
                }
                
                // Apply threshold
                if (depthValue < this.depthThreshold) depthValue = 0;
                
                // Apply smoothing
                depthValue = this.applyDepthSmoothing(depthValue);
                
                // Apply strength
                depthValue = Math.min(1, depthValue * this.depthMapStrength);
                
                // Set depth map pixel
                const depthColor = depthValue * 255;
                depthMap.data[i] = depthColor;
                depthMap.data[i + 1] = depthColor;
                depthMap.data[i + 2] = depthColor;
                depthMap.data[i + 3] = 255;
            }
            
            this.depthCanvasCtx.putImageData(depthMap, 0, 0);
            this.currentDepthMap = depthMap;
        }

        getLuminance(data, x, y, width) {
            const idx = (y * width + x) * 4;
            return 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
        }

        generateFallbackDepthMap(width, height) {
            const imageData = this.tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const depthMap = this.depthCanvasCtx.createImageData(width, height);
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                let depthValue = 0;
                
                switch (this.depthMode) {
                    case 'luminance':
                        depthValue = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                        break;
                        
                    case 'edges':
                        if (i > 4 && i < data.length - 4) {
                            const prevLum = (0.299 * data[i-4] + 0.587 * data[i-3] + 0.114 * data[i-2]) / 255;
                            const currLum = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                            depthValue = Math.min(1, Math.abs(currLum - prevLum) * 5);
                        }
                        break;
                        
                    default:
                        depthValue = 0.5;
                        break;
                }
                
                // Apply depth inversion if enabled
                if (this.invertDepth) {
                    depthValue = 1 - depthValue;
                }
                
                if (depthValue < this.depthThreshold) depthValue = 0;
                depthValue = this.applyDepthSmoothing(depthValue);
                depthValue = Math.min(1, depthValue * this.depthMapStrength);
                
                depthMap.data[i] = depthValue * 255;
                depthMap.data[i + 1] = depthValue * 255;
                depthMap.data[i + 2] = depthValue * 255;
                depthMap.data[i + 3] = 255;
            }
            
            this.depthCanvasCtx.putImageData(depthMap, 0, 0);
            this.currentDepthMap = depthMap;
        }

        applyDepthSmoothing(depthValue) {
            if (this.depthSmoothing === 0) return depthValue;
            const smoothingFactor = Math.max(0.1, 1 - (this.depthSmoothing / 15));
            return Math.pow(depthValue, smoothingFactor);
        }

        renderEyeViews(width, height) {
            if (this.depthMode !== 'api' && this.currentDepthMap) {
                this.renderEnhancedEyeViews(width, height);
            } else {
                const baseSeparation = this.separation * this.depth;
                this.renderUniformEyeViews(width, height, baseSeparation);
            }
        }

        renderEnhancedEyeViews(width, height) {
            const baseSeparation = this.separation * this.depth;
            const processedDepth = this.processDepthMap(width, height);
            
            // Draw base images
            this.leftCanvasCtx.drawImage(this.video, 0, 0, width, height);
            this.rightCanvasCtx.drawImage(this.video, 0, 0, width, height);
            
            // Get image data
            const leftData = this.leftCanvasCtx.getImageData(0, 0, width, height);
            const rightData = this.rightCanvasCtx.getImageData(0, 0, width, height);
            
            // Apply convergence-aware displacement
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const depthIdx = (y * width + x) * 4;
                    const depthValue = processedDepth.data[depthIdx] / 255;
                    
                    const displacement = baseSeparation * (depthValue - 0.5) * 2;
                    
                    const leftSrcX = Math.floor(Math.max(0, Math.min(width - 1, x + displacement)));
                    const rightSrcX = Math.floor(Math.max(0, Math.min(width - 1, x - displacement)));
                    
                    const srcIdx = (y * width + x) * 4;
                    const leftSrcIdx = (y * width + leftSrcX) * 4;
                    const rightSrcIdx = (y * width + rightSrcX) * 4;
                    
                    // Copy pixels with convergence-aware displacement
                    for (let i = 0; i < 3; i++) {
                        leftData.data[srcIdx + i] = rightData.data[leftSrcIdx + i];
                        rightData.data[srcIdx + i] = leftData.data[rightSrcIdx + i];
                    }
                }
            }
            
            // Put modified data back
            this.leftCanvasCtx.putImageData(leftData, 0, 0);
            this.rightCanvasCtx.putImageData(rightData, 0, 0);
            
            // Update depth visualization
            this.updateDepthVisualization();
        }

        processDepthMap(width, height) {
            if (!this.currentDepthMap) return null;

            const depthData = this.currentDepthMap.data;
            const processedDepth = this.depthCanvasCtx.createImageData(width, height);
            const displacementMap = this.depthCanvasCtx.createImageData(width, height);
            
            let min = 1, max = 0, sum = 0;
            const histogram = new Array(20).fill(0);
            
            // First pass: calculate statistics
            for (let i = 0; i < depthData.length; i += 4) {
                const depthValue = depthData[i] / 255;
                min = Math.min(min, depthValue);
                max = Math.max(max, depthValue);
                sum += depthValue;
                
                const bin = Math.min(19, Math.floor(depthValue * 20));
                histogram[bin]++;
            }
            
            const avg = sum / (depthData.length / 4);
            
            // Auto convergence calculation
            if (this.autoConvergence > 0) {
                const autoConv = this.calculateAutoConvergence(histogram, min, max);
                this.convergence = this.convergence * (1 - this.autoConvergence/100) + 
                                 autoConv * (this.autoConvergence/100);
                this.convergenceSlider.value = this.convergence;
                this.convergenceValue.textContent = this.convergence.toFixed(2);
                this.convergenceMarker.style.left = (this.convergence * 100) + '%';
            }
            
            // Second pass: apply depth processing
            for (let i = 0; i < depthData.length; i += 4) {
                let depthValue = depthData[i] / 255;
                
                // Normalize to full range
                depthValue = (depthValue - min) / (max - min || 1);
                
                // Apply depth curve
                depthValue = Math.pow(depthValue, this.depthCurve);
                
                // Apply depth range
                depthValue = 0.5 + (depthValue - 0.5) * this.depthRange;
                depthValue = Math.max(0, Math.min(1, depthValue));
                
                // Convergence adjustment
                const convergedDepth = this.applyConvergence(depthValue);
                
                // Set processed depth
                const depthColor = convergedDepth * 255;
                processedDepth.data[i] = depthColor;
                processedDepth.data[i + 1] = depthColor;
                processedDepth.data[i + 2] = depthColor;
                processedDepth.data[i + 3] = 255;
                
                // Calculate displacement for visualization
                const displacement = this.calculateDisplacement(convergedDepth);
                const dispColor = Math.abs(displacement) * 255;
                displacementMap.data[i] = displacement > 0 ? dispColor : 0;
                displacementMap.data[i + 1] = 128;
                displacementMap.data[i + 2] = displacement < 0 ? dispColor : 0;
                displacementMap.data[i + 3] = 255;
            }
            
            // Update statistics
            this.depthStats = { min, max, avg, histogram };
            this.updateDepthVisualization();
            this.updateDepthStats();
            
            return processedDepth;
        }

        applyConvergence(depthValue) {
            // Adjust depth based on convergence point
            if (depthValue < this.convergence) {
                // Objects in front of convergence plane
                return 0.5 - (this.convergence - depthValue) / this.convergence * 0.5;
            } else {
                // Objects behind convergence plane
                return 0.5 + (depthValue - this.convergence) / (1 - this.convergence) * 0.5;
            }
        }

        calculateDisplacement(depthValue) {
            const baseSeparation = this.separation * this.depth;
            return (depthValue - 0.5) * baseSeparation * 2;
        }

        calculateAutoConvergence(histogram, min, max) {
            // Find the most common depth range (mode)
            let maxCount = 0;
            let modeBin = 10;

            for (let i = 0; i < histogram.length; i++) {
                if (histogram[i] > maxCount) {
                    maxCount = histogram[i];
                    modeBin = i;
                }
            }

            // Weighted average of prominent depth regions
            let weightedSum = 0;
            let totalWeight = 0;

            for (let i = 0; i < histogram.length; i++) {
                if (histogram[i] > maxCount * 0.1) {
                    const weight = histogram[i];
                    const depth = (i + 0.5) / histogram.length;
                    weightedSum += depth * weight;
                    totalWeight += weight;
                }
            }

            return totalWeight > 0 ? weightedSum / totalWeight : 0.5;
        }

        updateDepthVisualization() {
            if (!this.currentDepthMap) return;

            const vizWidth = this.rawDepthViz.width;
            const vizHeight = this.rawDepthViz.height;
            
            // Raw depth visualization
            this.rawDepthCtx.drawImage(this.depthCanvas, 0, 0, vizWidth, vizHeight);
            
            // Processed depth visualization
            const processedDepth = this.processDepthMap(this.depthCanvas.width, this.depthCanvas.height);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.depthCanvas.width;
            tempCanvas.height = this.depthCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(processedDepth, 0, 0);
            this.processedDepthCtx.drawImage(tempCanvas, 0, 0, vizWidth, vizHeight);
            
            // Displacement visualization
            this.updateDisplacementVisualization(vizWidth, vizHeight);
            
            // Update histogram
            this.updateDepthHistogram();
        }

        updateDisplacementVisualization(width, height) {
            this.displacementCtx.fillStyle = '#000';
            this.displacementCtx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            
            for (let x = 0; x < width; x++) {
                const depthValue = x / width;
                const convergedDepth = this.applyConvergence(depthValue);
                const displacement = this.calculateDisplacement(convergedDepth);
                
                const y = height / 2;
                const displacementX = centerX + displacement * (width / 200);
                
                this.displacementCtx.fillStyle = `hsl(${240 - displacement * 100}, 100%, 50%)`;
                this.displacementCtx.fillRect(displacementX, y - 1, 2, 3);
            }
            
            // Draw convergence line
            this.displacementCtx.strokeStyle = '#fff';
            this.displacementCtx.setLineDash([5, 5]);
            this.displacementCtx.beginPath();
            const convX = centerX + (this.convergence - 0.5) * width;
            this.displacementCtx.moveTo(convX, 0);
            this.displacementCtx.lineTo(convX, height);
            this.displacementCtx.stroke();
            this.displacementCtx.setLineDash([]);
        }

        updateDepthHistogram() {
            this.depthHistogram.innerHTML = '';
            const { histogram, min, max } = this.depthStats;
            const maxFreq = Math.max(...histogram);
            
            histogram.forEach((freq, i) => {
                const bar = document.createElement('div');
                bar.className = 'histogram-bar';
                const height = (freq / maxFreq) * 50;
                bar.style.height = height + 'px';
                bar.style.left = (i * 5) + '%';
                bar.style.background = `hsl(${240 - i * 12}, 100%, 50%)`;
                this.depthHistogram.appendChild(bar);
            });
        }

        updateDepthStats() {
            this.minDepth.textContent = this.depthStats.min.toFixed(2);
            this.maxDepth.textContent = this.depthStats.max.toFixed(2);
            this.avgDepth.textContent = this.depthStats.avg.toFixed(2);
        }

        analyzeDepthScene() {
            if (!this.currentDepthMap) return;
            
            const analysis = this.performDepthAnalysis();
            this.showDepthAnalysis(analysis);
        }

        performDepthAnalysis() {
            const { min, max, avg, histogram } = this.depthStats;
            const depthRange = max - min;
            
            // Calculate depth complexity (entropy)
            let entropy = 0;
            const totalPixels = histogram.reduce((sum, val) => sum + val, 0);
            
            histogram.forEach(count => {
                if (count > 0) {
                    const probability = count / totalPixels;
                    entropy -= probability * Math.log2(probability);
                }
            });
            
            // Determine scene type
            let sceneType = "Balanced";
            if (entropy < 1.5) sceneType = "Simple/Flat";
            else if (entropy > 2.5) sceneType = "Complex/Detailed";
            
            // Recommended settings
            const recommendedConvergence = this.calculateAutoConvergence(histogram, min, max);
            const recommendedDepthRange = Math.min(2, Math.max(0.5, 1 / depthRange));
            
            return {
                sceneType,
                depthRange: depthRange.toFixed(3),
                complexity: entropy.toFixed(2),
                recommendedConvergence: recommendedConvergence.toFixed(2),
                recommendedDepthRange: recommendedDepthRange.toFixed(1),
                note: this.getSceneAdvice(sceneType, depthRange)
            };
        }

        getSceneAdvice(sceneType, depthRange) {
            if (sceneType === "Simple/Flat") {
                return "Consider increasing depth range for more 3D effect";
            } else if (sceneType === "Complex/Detailed") {
                return "Use moderate depth range to avoid eye strain";
            } else {
                return "Current depth settings should work well";
            }
        }

        showDepthAnalysis(analysis) {
            const analysisHTML = `
                <div class="instructions">
                    <button class="close-instructions" onclick="this.parentElement.remove()">×</button>
                    <h3><i class="fas fa-chart-bar"></i> Depth Scene Analysis</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div>
                            <strong>Scene Type:</strong> ${analysis.sceneType}<br>
                            <strong>Depth Range:</strong> ${analysis.depthRange}<br>
                            <strong>Complexity:</strong> ${analysis.complexity}
                        </div>
                        <div>
                            <strong>Recommended Convergence:</strong> ${analysis.recommendedConvergence}<br>
                            <strong>Recommended Depth Range:</strong> ${analysis.recommendedDepthRange}
                        </div>
                    </div>
                    <div class="note">${analysis.note}</div>
                    <button onclick="this.closest('.instructions').remove(); videoRenderer.applyRecommendedSettings(${analysis.recommendedConvergence}, ${analysis.recommendedDepthRange})" style="margin-top: 15px;">
                        <i class="fas fa-magic"></i> Apply Recommended Settings
                    </button>
                </div>
            `;
            
            const exportGroup = document.querySelector('.control-group:last-child');
            exportGroup.parentNode.insertBefore(document.createRange().createContextualFragment(analysisHTML), exportGroup.nextSibling);
        }

        applyRecommendedSettings(convergence, depthRange) {
            this.convergenceSlider.value = convergence;
            this.convergence = parseFloat(convergence);
            this.convergenceValue.textContent = convergence;
            this.convergenceMarker.style.left = (convergence * 100) + '%';
            
            this.depthRangeSlider.value = depthRange;
            this.depthRange = parseFloat(depthRange);
            this.depthRangeValue.textContent = depthRange;
            
            this.renderCurrentFrame();
        }

        renderUniformEyeViews(width, height, baseSeparation) {
            this.renderEyeView(this.leftCanvasCtx, -baseSeparation, width, height);
            this.renderEyeView(this.rightCanvasCtx, baseSeparation, width, height);
        }

        renderEyeView(ctx, offset, width, height) {
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw the main image (shifted) while maintaining aspect ratio
            ctx.drawImage(this.video, offset, 0, width, height, 0, 0, width, height);
            
            // Apply hole filling to eliminate gaps
            this.applyHoleFill(ctx, offset, width, height);
        }

        applyHoleFill(ctx, offset, width, height) {
            const gapSize = Math.abs(offset);
            
            if (offset < 0) {
                // Fill left gap
                ctx.drawImage(
                    this.video,
                    0, 0, 1, height,
                    0, 0, gapSize, height
                );
            } else if (offset > 0) {
                // Fill right gap
                ctx.drawImage(
                    this.video,
                    width - 1, 0, 1, height,
                    width - gapSize, 0, gapSize, height
                );
            }
        }

        renderView() {
            const { width, height } = this.outputCanvas;

            // Remove any existing view indicators
            const existingIndicators = document.querySelectorAll('.view-indicator');
            existingIndicators.forEach(indicator => indicator.remove());

            switch (this.currentView) {
                case 'left':
                    this.ctx.drawImage(this.leftCanvas, 0, 0, width, height);
                    break;
                case 'right':
                    this.ctx.drawImage(this.rightCanvas, 0, 0, width, height);
                    break;
                case 'sideBySide':
                    this.renderSideBySide();
                    break;
                case 'topBottom':
                    this.renderTopBottom();
                    break;
                case 'depth':
                    this.ctx.drawImage(this.depthCanvas, 0, 0, width, height);
                    break;
            }
        }

        renderSideBySide() {
            const { width, height } = this.outputCanvas;
            
            // Clear the output canvas
            this.ctx.clearRect(0, 0, width, height);
            
            // Calculate dimensions for each view
            const viewWidth = width / 2;
            const viewHeight = height;
            
            // Calculate scaling to maintain aspect ratio
            const videoAspect = this.originalVideoWidth / this.originalVideoHeight;
            const viewAspect = viewWidth / viewHeight;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (videoAspect > viewAspect) {
                // Video is wider than view - fit to width
                drawWidth = viewWidth;
                drawHeight = viewWidth / videoAspect;
                offsetX = 0;
                offsetY = (viewHeight - drawHeight) / 2;
            } else {
                // Video is taller than view - fit to height
                drawHeight = viewHeight;
                drawWidth = viewHeight * videoAspect;
                offsetX = (viewWidth - drawWidth) / 2;
                offsetY = 0;
            }
            
            // Draw left and right views with proper aspect ratio
            this.ctx.drawImage(
                this.leftCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                0, offsetY, drawWidth, drawHeight
            );
            
            this.ctx.drawImage(
                this.rightCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                viewWidth, offsetY, drawWidth, drawHeight
            );
            
            // Add view indicators
            this.addViewIndicators('sbs');
        }

        renderTopBottom() {
            const { width, height } = this.outputCanvas;
            
            // Clear the output canvas
            this.ctx.clearRect(0, 0, width, height);
            
            // Calculate dimensions for each view
            const viewWidth = width;
            const viewHeight = height / 2;
            
            // Calculate scaling to maintain aspect ratio
            const videoAspect = this.originalVideoWidth / this.originalVideoHeight;
            const viewAspect = viewWidth / viewHeight;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (videoAspect > viewAspect) {
                // Video is wider than view - fit to width
                drawWidth = viewWidth;
                drawHeight = viewWidth / videoAspect;
                offsetX = 0;
                offsetY = (viewHeight - drawHeight) / 2;
            } else {
                // Video is taller than view - fit to height
                drawHeight = viewHeight;
                drawWidth = viewHeight * videoAspect;
                offsetX = (viewWidth - drawWidth) / 2;
                offsetY = 0;
            }
            
            // Draw top and bottom views with proper aspect ratio
            this.ctx.drawImage(
                this.leftCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                offsetX, 0, drawWidth, drawHeight
            );
            
            this.ctx.drawImage(
                this.rightCanvas, 
                0, 0, this.originalVideoWidth, this.originalVideoHeight,
                offsetX, viewHeight, drawWidth, drawHeight
            );
            
            // Add view indicators
            this.addViewIndicators('tb');
        }

        // FIXED: Export current frame with guaranteed rendering
        exportCurrentFrame() {
            if (!this.video) return;

            // Force a synchronous render to ensure canvas is updated
            this.renderCurrentFrameSync();
            
            // Create a canvas with the exact output dimensions and content
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = this.outputCanvas.width;
            exportCanvas.height = this.outputCanvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Draw the current output exactly as shown
            exportCtx.drawImage(this.outputCanvas, 0, 0);
            
            // Create and trigger download
            const link = document.createElement('a');
            link.download = `polarization_frame_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        // Polarization format rendering method
        renderPolarizationFormat() {
            switch (this.polarizationFormat) {
                case 'side-by-side':
                    this.renderSideBySide();
                    break;
                case 'top-bottom':
                    this.renderTopBottom();
                    break;
                case 'interlaced':
                    this.encodeInterlacedPolarization();
                    break;
                case 'checkerboard':
                    this.encodeCheckerboardPolarization();
                    break;
            }
        }

        // Interlaced polarization encoding
        encodeInterlacedPolarization() {
            const { width, height } = this.outputCanvas;
            const imageData = this.ctx.createImageData(width, height);
            const leftData = this.leftCanvasCtx.getImageData(0, 0, width, height).data;
            const rightData = this.rightCanvasCtx.getImageData(0, 0, width, height).data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Even lines: left eye (vertical polarization)
                    // Odd lines: right eye (horizontal polarization)
                    const sourceData = (y % 2 === 0) ? leftData : rightData;
                    
                    imageData.data[idx] = sourceData[idx];
                    imageData.data[idx + 1] = sourceData[idx + 1];
                    imageData.data[idx + 2] = sourceData[idx + 2];
                    imageData.data[idx + 3] = 255;
                }
            }
            
            this.ctx.putImageData(imageData, 0, 0);
        }

        // Checkerboard polarization encoding
        encodeCheckerboardPolarization() {
            const { width, height } = this.outputCanvas;
            const imageData = this.ctx.createImageData(width, height);
            const leftData = this.leftCanvasCtx.getImageData(0, 0, width, height).data;
            const rightData = this.rightCanvasCtx.getImageData(0, 0, width, height).data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Checkerboard pattern
                    const isLeftEye = (x % 2 === 0 && y % 2 === 0) || (x % 2 === 1 && y % 2 === 1);
                    const sourceData = isLeftEye ? leftData : rightData;
                    
                    imageData.data[idx] = sourceData[idx];
                    imageData.data[idx + 1] = sourceData[idx + 1];
                    imageData.data[idx + 2] = sourceData[idx + 2];
                    imageData.data[idx + 3] = 255;
                }
            }
            
            this.ctx.putImageData(imageData, 0, 0);
        }

        // Method to add view indicators
        addViewIndicators(viewType) {
            if (viewType === 'sbs') {
                // Add left and right indicators for side-by-side view
                const leftIndicator = document.createElement('div');
                leftIndicator.className = 'view-indicator sbs-indicator-left';
                leftIndicator.textContent = 'LEFT EYE';
                this.outputCanvas.parentNode.appendChild(leftIndicator);
                
                const rightIndicator = document.createElement('div');
                rightIndicator.className = 'view-indicator sbs-indicator-right';
                rightIndicator.textContent = 'RIGHT EYE';
                this.outputCanvas.parentNode.appendChild(rightIndicator);
            } else if (viewType === 'tb') {
                // Add top and bottom indicators for top-bottom view
                const topIndicator = document.createElement('div');
                topIndicator.className = 'view-indicator tb-indicator-top';
                topIndicator.textContent = 'LEFT EYE (TOP)';
                this.outputCanvas.parentNode.appendChild(topIndicator);
                
                const bottomIndicator = document.createElement('div');
                bottomIndicator.className = 'view-indicator tb-indicator-bottom';
                bottomIndicator.textContent = 'RIGHT EYE (BOTTOM)';
                this.outputCanvas.parentNode.appendChild(bottomIndicator);
            }
        }

        // FIXED: Update previews with consistent aspect ratio
        updatePreviews() {
            const previewWidth = this.leftPreview.width;
            const previewHeight = this.leftPreview.height;

            // Clear preview canvases
            this.leftCtx.fillStyle = '#000';
            this.leftCtx.fillRect(0, 0, previewWidth, previewHeight);
            this.rightCtx.fillStyle = '#000';
            this.rightCtx.fillRect(0, 0, previewWidth, previewHeight);
            this.depthCtx.fillStyle = '#000';
            this.depthCtx.fillRect(0, 0, previewWidth, previewHeight);
            
            // Calculate scaling to maintain aspect ratio (same as output)
            const videoAspect = this.originalVideoWidth / this.originalVideoHeight;
            const previewAspect = previewWidth / previewHeight;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (videoAspect > previewAspect) {
                // Video is wider than preview - fit to width
                drawWidth = previewWidth;
                drawHeight = previewWidth / videoAspect;
                offsetX = 0;
                offsetY = (previewHeight - drawHeight) / 2;
            } else {
                // Video is taller than preview - fit to height
                drawHeight = previewHeight;
                drawWidth = previewHeight * videoAspect;
                offsetX = (previewWidth - drawWidth) / 2;
                offsetY = 0;
            }
            
            // Draw with the same aspect ratio handling as main output
            this.leftCtx.drawImage(this.leftCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                  offsetX, offsetY, drawWidth, drawHeight);
            this.rightCtx.drawImage(this.rightCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                   offsetX, offsetY, drawWidth, drawHeight);
            this.depthCtx.drawImage(this.depthCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                   offsetX, offsetY, drawWidth, drawHeight);
        }

        setView(view) {
            this.currentView = view;
            
            // Update button states
            Object.entries(this.viewButtons).forEach(([v, button]) => {
                button.classList.toggle('active', v === view);
            });

            this.renderCurrentFrame();
        }

        // Enhanced Fullscreen Methods
        enterFullscreen() {
            if (!this.video) return;
            
            this.isFullscreen = true;
            this.fullscreenOverlay.style.display = 'flex';
            
            // Set fullscreen canvas size to match viewport
            this.updateFullscreenCanvasSize();
            
            // Start rendering to fullscreen canvas
            this.updateFullscreen();
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // Show share screen button if supported
            if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                this.shareScreenBtn.style.display = 'block';
            }
        }

        updateFullscreenCanvasSize() {
            this.fullscreenCanvas.width = window.innerWidth;
            this.fullscreenCanvas.height = window.innerHeight;
        }

        exitFullscreen() {
            this.isFullscreen = false;
            this.fullscreenOverlay.style.display = 'none';
            this.isMirrored = false;
            
            // Stop screen sharing if active
            if (this.isSharingScreen) {
                this.stopScreenSharing();
            }
            
            // Restore body scroll
            document.body.style.overflow = 'auto';
            
            // Hide share screen button
            this.shareScreenBtn.style.display = 'none';
        }

        toggleMirror() {
            this.isMirrored = !this.isMirrored;
            this.fsMirror.innerHTML = this.isMirrored ? 
                '<i class="fas fa-sync-alt"></i> Unmirror Display' : 
                '<i class="fas fa-sync-alt"></i> Mirror Display';
            this.updateFullscreen();
        }

        updateFullscreen() {
            if (!this.isFullscreen) return;
            
            const fsWidth = this.fullscreenCanvas.width;
            const fsHeight = this.fullscreenCanvas.height;
            const srcWidth = this.outputCanvas.width;
            const srcHeight = this.outputCanvas.height;
            
            // Clear fullscreen canvas
            this.fsCtx.fillStyle = '#000';
            this.fsCtx.fillRect(0, 0, fsWidth, fsHeight);
            
            // Calculate aspect ratio and scaling while maintaining original proportions
            const aspectRatio = srcWidth / srcHeight;
            let drawWidth = fsWidth;
            let drawHeight = fsWidth / aspectRatio;
            
            if (drawHeight > fsHeight) {
                drawHeight = fsHeight;
                drawWidth = fsHeight * aspectRatio;
            }
            
            const x = (fsWidth - drawWidth) / 2;
            const y = (fsHeight - drawHeight) / 2;
            
            // Draw with or without mirroring while maintaining aspect ratio
            if (this.isMirrored) {
                this.fsCtx.save();
                this.fsCtx.translate(fsWidth, 0);
                this.fsCtx.scale(-1, 1);
                this.fsCtx.drawImage(this.outputCanvas, fsWidth - x - drawWidth, y, drawWidth, drawHeight);
                this.fsCtx.restore();
            } else {
                this.fsCtx.drawImage(this.outputCanvas, x, y, drawWidth, drawHeight);
            }
        }

        // Screen Sharing Methods
        async startScreenSharing() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                alert("Screen sharing is not supported in your browser.");
                return;
            }

            try {
                // Get screen stream
                this.screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: "always"
                    },
                    audio: false
                });

                // Create video element for screen capture
                if (!this.screenVideo) {
                    this.screenVideo = document.createElement('video');
                    this.screenVideo.autoplay = true;
                    this.screenVideo.muted = true;
                }

                // Set the stream as the video source
                this.screenVideo.srcObject = this.screenStream;
                
                // Update UI
                this.isSharingScreen = true;
                this.sharingInfo.style.display = 'block';
                this.fsShare.innerHTML = '<i class="fas fa-stop"></i> Stop Sharing';
                this.fsShare.classList.add('active');
                
                // Handle when user stops sharing
                this.screenStream.getTracks().forEach(track => {
                    track.onended = () => {
                        this.stopScreenSharing();
                    };
                });

                // Start rendering screen to fullscreen canvas
                this.renderScreenToFullscreen();

            } catch (error) {
                console.error("Error starting screen sharing:", error);
                alert("Failed to start screen sharing: " + error.message);
            }
        }

        stopScreenSharing() {
            if (this.screenStream) {
                this.screenStream.getTracks().forEach(track => track.stop());
                this.screenStream = null;
            }
            
            this.isSharingScreen = false;
            this.sharingInfo.style.display = 'none';
            this.fsShare.innerHTML = '<i class="fas fa-share-alt"></i> Share Screen';
            this.fsShare.classList.remove('active');
            
            // Return to normal rendering
            this.updateFullscreen();
        }

        renderScreenToFullscreen() {
            if (!this.isSharingScreen || !this.screenVideo) return;

            const fsWidth = this.fullscreenCanvas.width;
            const fsHeight = this.fullscreenCanvas.height;
            
            // Clear canvas
            this.fsCtx.fillStyle = '#000';
            this.fsCtx.fillRect(0, 0, fsWidth, fsHeight);
            
            // Draw screen capture
            this.fsCtx.drawImage(this.screenVideo, 0, 0, fsWidth, fsHeight);
            
            // Continue rendering
            requestAnimationFrame(() => this.renderScreenToFullscreen());
        }

        exportAsMP4() {
            if (!this.video) return;
            
            alert("For MP4 export:\n1. Export frames as ZIP\n2. Convert using FFmpeg\n3. See instructions for details");
        }

        getExportResolution() {
            switch (this.exportResolution) {
                case '720': return { width: 1280, height: 720 };
                case '1080': return { width: 1920, height: 1080 };
                case '2160': return { width: 3840, height: 2160 };
                default: return { 
                    width: this.video.videoWidth, 
                    height: this.video.videoHeight 
                };
            }
        }

        // FIXED: Export as ZIP with guaranteed frame rendering
        exportAsZip() {
            if (!this.video || this.isExporting) return;
            
            // Warn for long videos
            if (this.video.duration > 30) {
                if (!confirm('This video is longer than 30 seconds. Exporting may take several minutes. Continue?')) {
                    return;
                }
            }

            this.isExporting = true;
            this.exportProgress.classList.remove('hidden');
            this.exportStatus.classList.remove('hidden');
            this.exportStatus.textContent = 'Preparing export...';
            this.exportStatus.className = 'status processing';

            // Disable buttons during export
            this.exportMP4Btn.disabled = true;
            this.exportZipBtn.disabled = true;
            this.playPauseBtn.disabled = true;
            this.stopBtn.disabled = true;

            // Store current video state
            const wasPlaying = this.isPlaying;
            const currentTime = this.video.currentTime;
            this.video.pause();
            this.isPlaying = false;

            // Get export resolution
            const resolution = this.getExportResolution();
            const exportWidth = resolution.width;
            const exportHeight = resolution.height;
            
            // Setup ZIP
            const zip = new JSZip();
            const frameRate = 30;
            const totalFrames = Math.ceil(this.video.duration * frameRate);
            let currentFrame = 0;
            
            // Create instructions file
            const instructions = this.getConversionInstructions();
            zip.file("INSTRUCTIONS.txt", instructions);

            // Create export canvas with consistent rendering
            const renderExportFrame = () => {
                // Force synchronous rendering of current frame
                this.renderCurrentFrameSync();
                
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = exportWidth;
                exportCanvas.height = exportHeight;
                const exportCtx = exportCanvas.getContext('2d');
                
                // Clear and draw exactly what would be shown in outputCanvas
                exportCtx.fillStyle = '#000';
                exportCtx.fillRect(0, 0, exportWidth, exportHeight);
                
                // Calculate scaling to maintain aspect ratio
                const videoAspect = this.originalVideoWidth / this.originalVideoHeight;
                const exportAspect = exportWidth / exportHeight;
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (videoAspect > exportAspect) {
                    // Video is wider than export - fit to width
                    drawWidth = exportWidth;
                    drawHeight = exportWidth / videoAspect;
                    offsetX = 0;
                    offsetY = (exportHeight - drawHeight) / 2;
                } else {
                    // Video is taller than export - fit to height
                    drawHeight = exportHeight;
                    drawWidth = exportHeight * videoAspect;
                    offsetX = (exportWidth - drawWidth) / 2;
                    offsetY = 0;
                }
                
                // Render based on polarization format with proper scaling
                switch (this.polarizationFormat) {
                    case 'side-by-side':
                        const halfWidth = drawWidth / 2;
                        exportCtx.drawImage(this.leftCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                           offsetX, offsetY, halfWidth, drawHeight);
                        exportCtx.drawImage(this.rightCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                           offsetX + halfWidth, offsetY, halfWidth, drawHeight);
                        break;
                        
                    case 'top-bottom':
                        const halfHeight = drawHeight / 2;
                        exportCtx.drawImage(this.leftCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                           offsetX, offsetY, drawWidth, halfHeight);
                        exportCtx.drawImage(this.rightCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                           offsetX, offsetY + halfHeight, drawWidth, halfHeight);
                        break;
                        
                    case 'interlaced':
                        // For interlaced, render directly to export canvas
                        this.renderInterlacedToCanvas(exportCtx, offsetX, offsetY, drawWidth, drawHeight);
                        break;
                        
                    case 'checkerboard':
                        // For checkerboard, render directly to export canvas
                        this.renderCheckerboardToCanvas(exportCtx, offsetX, offsetY, drawWidth, drawHeight);
                        break;
                }
                
                return exportCanvas.toDataURL('image/png');
            };

            // NEW: Direct interlaced rendering to target canvas
            this.renderInterlacedToCanvas = (ctx, x, y, width, height) => {
                // Create temporary canvas at export resolution
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Get scaled versions of left and right images
                tempCtx.drawImage(this.leftCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                 0, 0, width, height);
                const leftData = tempCtx.getImageData(0, 0, width, height);
                
                tempCtx.drawImage(this.rightCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                 0, 0, width, height);
                const rightData = tempCtx.getImageData(0, 0, width, height);
                
                // Create interlaced image
                const imageData = tempCtx.createImageData(width, height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Even lines: left eye (vertical polarization)
                        // Odd lines: right eye (horizontal polarization)
                        const sourceData = (y % 2 === 0) ? leftData.data : rightData.data;
                        
                        imageData.data[idx] = sourceData[idx];
                        imageData.data[idx + 1] = sourceData[idx + 1];
                        imageData.data[idx + 2] = sourceData[idx + 2];
                        imageData.data[idx + 3] = 255;
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(tempCanvas, x, y);
            };

            // NEW: Direct checkerboard rendering to target canvas
            this.renderCheckerboardToCanvas = (ctx, x, y, width, height) => {
                // Create temporary canvas at export resolution
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Get scaled versions of left and right images
                tempCtx.drawImage(this.leftCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                 0, 0, width, height);
                const leftData = tempCtx.getImageData(0, 0, width, height);
                
                tempCtx.drawImage(this.rightCanvas, 0, 0, this.originalVideoWidth, this.originalVideoHeight, 
                                 0, 0, width, height);
                const rightData = tempCtx.getImageData(0, 0, width, height);
                
                // Create checkerboard image
                const imageData = tempCtx.createImageData(width, height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Checkerboard pattern
                        const isLeftEye = (x % 2 === 0 && y % 2 === 0) || (x % 2 === 1 && y % 2 === 1);
                        const sourceData = isLeftEye ? leftData.data : rightData.data;
                        
                        imageData.data[idx] = sourceData[idx];
                        imageData.data[idx + 1] = sourceData[idx + 1];
                        imageData.data[idx + 2] = sourceData[idx + 2];
                        imageData.data[idx + 3] = 255;
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(tempCanvas, x, y);
            };

            // Function to process a frame with guaranteed rendering
            const processFrame = async () => {
                if (currentFrame >= totalFrames) {
                    // Finish up
                    this.exportStatus.textContent = 'Compressing frames...';
                    zip.generateAsync({type:"blob"}, (metadata) => {
                        const progress = 90 + (metadata.percent / 10);
                        this.exportProgressFill.style.width = progress + '%';
                        this.exportProgressFill.textContent = Math.floor(progress) + '%';
                    }).then(blob => {
                        // Download the zip
                        saveAs(blob, `polarization_frames_${exportWidth}x${exportHeight}_${Date.now()}.zip`);

                        // Restore video state
                        this.video.currentTime = currentTime;
                        if (wasPlaying) {
                            this.video.play();
                            this.isPlaying = true;
                        }

                        // Update UI
                        this.exportStatus.textContent = 'Export completed!';
                        this.exportStatus.className = 'status ready';
                        this.isExporting = false;
                        this.exportMP4Btn.disabled = false;
                        this.exportZipBtn.disabled = false;
                        this.playPauseBtn.disabled = false;
                        this.stopBtn.disabled = false;

                        // Show success message
                        this.showConversionSuccess();
                        
                        setTimeout(() => {
                            this.exportProgress.classList.add('hidden');
                            this.exportStatus.classList.add('hidden');
                        }, 5000);
                    });
                    return;
                }

                // Calculate the time for this frame
                const time = currentFrame / frameRate;
                this.video.currentTime = time;

                // Wait for the video to seek to the time
                const seekHandler = async () => {
                    this.video.removeEventListener('seeked', seekHandler);
                    
                    // Add a small delay to ensure video frame is ready
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    // Force synchronous rendering to ensure all canvases are updated
                    this.renderCurrentFrameSync();
                    
                    // Render the export frame with consistent quality
                    const dataURL = renderExportFrame();
                    
                    // Convert to blob and add to zip
                    fetch(dataURL)
                        .then(res => res.blob())
                        .then(blob => {
                            // Add to zip
                            zip.file(`frame_${currentFrame.toString().padStart(5, '0')}.png`, blob);

                            // Update progress
                            const percent = Math.floor((currentFrame + 1) / totalFrames * 100);
                            this.exportProgressFill.style.width = percent + '%';
                            this.exportProgressFill.textContent = percent + '%';
                            this.exportStatus.textContent = `Exporting frame ${currentFrame+1} of ${totalFrames} at ${exportWidth}x${exportHeight}...`;

                            currentFrame++;
                            
                            // Schedule next frame (allow UI updates)
                            setTimeout(processFrame, 0);
                        });
                };

                this.video.addEventListener('seeked', seekHandler);
            };

            // Start processing
            processFrame();
        }

        getConversionInstructions() {
            return `HOW TO CONVERT YOUR EXPORTED FRAMES TO VIDEO:
============================================

1. Unzip the downloaded file to a folder on your computer

2. Install FFmpeg:
   - Windows: Download from https://ffmpeg.org/download.html
   - Mac: Install using Homebrew: $ brew install ffmpeg
   - Linux: $ sudo apt install ffmpeg

3. Open a terminal/command prompt in the folder containing the frames

4. Run this command to create an MP4 video:
   ffmpeg -framerate 30 -i frame_%05d.png -c:v libx264 -pix_fmt yuv420p -crf 18 output.mp4

Command explanation:
   -framerate 30   : Match your source video's frame rate
   -i frame_%05d.png: Input pattern for frames (5-digit numbering)
   -c:v libx264    : Use H.264 encoding
   -pix_fmt yuv420p: Compatible pixel format
   -crf 18         : High quality (lower number = better quality)

For higher quality (larger file size):
   ffmpeg -framerate 30 -i frame_%05d.png -c:v libx264 -preset slow -crf 15 output.mp4

For smaller file size:
   ffmpeg -framerate 30 -i frame_%05d.png -c:v libx264 -preset fast -crf 23 output.mp4

Troubleshooting:
- If you get "file not found" error, ensure:
  1. You're in the correct folder with the frames
  2. The frame names match the pattern (frame_00000.png, frame_00001.png, etc.)
- On Windows, use Command Prompt or PowerShell (not Bash)
`;
        }

        showConversionSuccess() {
            const instructionsDiv = document.createElement('div');
            instructionsDiv.className = 'instructions';
            instructionsDiv.innerHTML = `
                <button class="close-instructions" onclick="this.parentElement.remove()">×</button>
                <h3><i class="fas fa-check-circle"></i> Export Successful!</h3>
                <p>Your polarization 3D frames have been exported and downloaded as a ZIP file.</p>
                <p>To convert to MP4:</p>
                <ol>
                    <li><strong>Unzip</strong> the downloaded file</li>
                    <li><strong>Install FFmpeg</strong> (see instructions below)</li>
                    <li><strong>Run this command</strong> in the unzipped folder:<br>
                        <code>ffmpeg -framerate 30 -i frame_%05d.png -c:v libx264 output.mp4</code>
                    </li>
                </ol>
                <div class="platform"><i class="fas fa-desktop"></i> Windows/Mac/Linux:</div>
                <div class="note">Detailed instructions are included in the ZIP file (INSTRUCTIONS.txt)</div>
            `;
            
            // Insert after export controls
            const exportGroup = document.querySelector('.control-group:last-child');
            exportGroup.parentNode.insertBefore(instructionsDiv, exportGroup.nextSibling);
        }
    }

    // Initialize everything when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        window.videoRenderer = new Polarization3DRenderer();
    });
</script>
</body>
</html>
