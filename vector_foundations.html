<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Foundations - Interactive Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #0a0a0f;
            --secondary: #1a1a2e;
            --accent-cyan: #00ffff;
            --accent-magenta: #ff00ff;
            --accent-yellow: #ffff00;
            --accent-orange: #ff6b00;
            --accent-green: #00ff00;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --border-radius: 12px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #0f0f23 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* Theory Panel */
        .theory-panel {
            background: rgba(26, 26, 46, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            padding: 20px;
            border: 1px solid rgba(128, 0, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-height: 800px;
            overflow-y: auto;
        }

        .theory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(128, 0, 255, 0.3);
        }

        .theory-header h2 {
            font-size: 1.5rem;
            color: var(--accent-magenta);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            display: none;
        }

        .theory-section {
            margin-bottom: 20px;
        }

        .theory-section h3 {
            color: var(--accent-cyan);
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .theory-section p {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .formula-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid var(--accent-cyan);
            margin: 15px 0;
            text-align: center;
        }

        .properties-list {
            list-style: none;
            padding-left: 0;
        }

        .properties-list li {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .properties-list li::before {
            content: "â€¢";
            color: var(--accent-magenta);
            font-weight: bold;
        }

        .highlight-box {
            background: rgba(75, 0, 130, 0.3);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(128, 0, 255, 0.3);
            margin: 15px 0;
        }

        .example-box {
            background: rgba(0, 100, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            margin: 15px 0;
        }

        .insight-box {
            background: rgba(184, 134, 11, 0.2);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            margin: 15px 0;
        }

        /* Canvas Panel */
        .canvas-panel {
            background: rgba(26, 26, 46, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            padding: 20px;
            border: 1px solid rgba(128, 0, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-active {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .btn-animate {
            background: linear-gradient(135deg, #ffa500, #ff4500);
            color: white;
        }

        .btn-animate:disabled {
            background: rgba(128, 128, 128, 0.3);
            cursor: not-allowed;
        }

        .btn-reset {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .slider-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-orange);
            cursor: pointer;
        }

        .canvas-container {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(128, 0, 255, 0.3);
            margin-bottom: 20px;
        }

        canvas {
            width: 100%;
            display: block;
            cursor: crosshair;
        }

        .vector-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid;
        }

        .info-box h4 {
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .info-box p {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .info-box .magnitude {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .vector-a {
            border-color: var(--accent-cyan);
        }

        .vector-b {
            border-color: var(--accent-magenta);
        }

        .vector-result {
            border-color: var(--accent-yellow);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .vector-info {
                grid-template-columns: 1fr;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Show theory button for mobile */
        .show-theory-btn {
            display: none;
            margin-bottom: 15px;
        }

        @media (max-width: 1024px) {
            .show-theory-btn {
                display: flex;
            }
            
            .theory-panel {
                display: none;
            }
            
            .theory-panel.active {
                display: block;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 500px;
                max-height: 80vh;
                z-index: 100;
            }
            
            .overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 99;
            }
            
            .overlay.active {
                display: block;
            }
        }

        /* MathJax styling */
        .MathJax {
            color: white !important;
            font-size: 1.1em !important;
        }

        mjx-container[jax="CHTML"][display="true"] {
            text-align: center !important;
            margin: 10px 0 !important;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(128, 0, 255, 0.5);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(128, 0, 255, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Vector Foundations</h1>
            <p>Interactive Visualization of Vector Operations â€¢ Drag vector endpoints to explore</p>
        </div>

        <button class="btn btn-primary show-theory-btn" id="showTheoryBtn">
            <i class="fas fa-book"></i> Show Theory
        </button>

        <div class="main-content">
            <div class="theory-panel" id="theoryPanel">
                <div class="theory-header">
                    <h2><i class="fas fa-book"></i> Vector Theory</h2>
                    <button class="close-btn" id="closeTheoryBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div id="theoryContent">
                    <!-- Theory content will be populated by JavaScript -->
                </div>
            </div>

            <div class="canvas-panel">
                <div class="controls">
                    <button class="btn btn-secondary" id="additionBtn">Vector Addition</button>
                    <button class="btn btn-secondary" id="scalarBtn">Scalar Multiplication</button>
                    <button class="btn btn-secondary" id="dotBtn">Dot Product</button>
                    
                    <div style="flex: 1;"></div>
                    
                    <button class="btn btn-animate" id="animateBtn">
                        <i class="fas fa-play"></i> Animate
                    </button>
                    
                    <button class="btn btn-reset" id="resetBtn">
                        <i class="fas fa-redo"></i> Reset
                    </button>
                </div>

                <div class="slider-container" id="scalarSliderContainer">
                    <label for="scalarSlider">Scalar: <span id="scalarValue">1.50</span></label>
                    <input type="range" id="scalarSlider" class="slider" min="-3" max="3" step="0.1" value="1.5">
                </div>
                
                <div class="canvas-container">
                    <canvas id="vectorCanvas" width="800" height="600"></canvas>
                </div>
                
                <div class="vector-info">
                    <div class="info-box vector-a">
                        <h4>Vector a</h4>
                        <p id="vectorAValue">(150, 100)</p>
                        <div class="magnitude">|a| = 180.28</div>
                    </div>
                    <div class="info-box vector-b">
                        <h4>Vector b</h4>
                        <p id="vectorBValue">(100, 150)</p>
                        <div class="magnitude">|b| = 180.28</div>
                    </div>
                    <div class="info-box vector-result">
                        <h4 id="resultTitle">a + b</h4>
                        <p id="resultValue">(250, 250)</p>
                        <div class="magnitude" id="resultMagnitude">|a+b| = 353.55</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <script>
        // State management
        const state = {
            mode: 'addition',
            vectorA: { x: 150, y: 100 },
            vectorB: { x: 100, y: 150 },
            scalar: 1.5,
            dragging: null,
            showGrid: true,
            animating: false,
            animProgress: 0,
            showTheory: true
        };

        // DOM elements
        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');
        const theoryPanel = document.getElementById('theoryPanel');
        const theoryContent = document.getElementById('theoryContent');
        const overlay = document.getElementById('overlay');
        const showTheoryBtn = document.getElementById('showTheoryBtn');
        const closeTheoryBtn = document.getElementById('closeTheoryBtn');
        const additionBtn = document.getElementById('additionBtn');
        const scalarBtn = document.getElementById('scalarBtn');
        const dotBtn = document.getElementById('dotBtn');
        const animateBtn = document.getElementById('animateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const scalarSlider = document.getElementById('scalarSlider');
        const scalarValue = document.getElementById('scalarValue');
        const scalarSliderContainer = document.getElementById('scalarSliderContainer');
        const vectorAValue = document.getElementById('vectorAValue');
        const vectorBValue = document.getElementById('vectorBValue');
        const resultTitle = document.getElementById('resultTitle');
        const resultValue = document.getElementById('resultValue');
        const resultMagnitude = document.getElementById('resultMagnitude');

        // Constants
        const origin = { x: 400, y: 300 };
        let animationInterval;

        // Initialize the application
        function init() {
            // Set up event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleMouseUp);
            
            additionBtn.addEventListener('click', () => setMode('addition'));
            scalarBtn.addEventListener('click', () => setMode('scalar'));
            dotBtn.addEventListener('click', () => setMode('dot'));
            
            animateBtn.addEventListener('click', startAnimation);
            resetBtn.addEventListener('click', resetVectors);
            
            scalarSlider.addEventListener('input', handleScalarChange);
            
            showTheoryBtn.addEventListener('click', showTheoryPanel);
            closeTheoryBtn.addEventListener('click', hideTheoryPanel);
            overlay.addEventListener('click', hideTheoryPanel);
            
            // Set up canvas for high DPI displays
            setupCanvas();
            
            // Initial render
            updateUI();
            draw();
        }

        // Set up canvas for high DPI displays
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            ctx.scale(dpr, dpr);
        }

        // Update UI based on state
        function updateUI() {
            // Update button states
            additionBtn.className = state.mode === 'addition' ? 'btn btn-active' : 'btn btn-secondary';
            scalarBtn.className = state.mode === 'scalar' ? 'btn btn-active' : 'btn btn-secondary';
            dotBtn.className = state.mode === 'dot' ? 'btn btn-active' : 'btn btn-secondary';
            
            // Update scalar slider visibility
            scalarSliderContainer.style.display = state.mode === 'scalar' ? 'block' : 'none';
            scalarValue.textContent = state.scalar.toFixed(2);
            
            // Update vector values
            vectorAValue.textContent = `(${state.vectorA.x.toFixed(0)}, ${state.vectorA.y.toFixed(0)})`;
            vectorBValue.textContent = `(${state.vectorB.x.toFixed(0)}, ${state.vectorB.y.toFixed(0)})`;
            
            // Update result values based on mode
            if (state.mode === 'addition') {
                resultTitle.textContent = 'a + b';
                resultValue.textContent = `(${(state.vectorA.x + state.vectorB.x).toFixed(0)}, ${(state.vectorA.y + state.vectorB.y).toFixed(0)})`;
                const magnitude = Math.sqrt((state.vectorA.x + state.vectorB.x)**2 + (state.vectorA.y + state.vectorB.y)**2);
                resultMagnitude.textContent = `|a+b| = ${magnitude.toFixed(2)}`;
            } else if (state.mode === 'scalar') {
                resultTitle.textContent = `${state.scalar.toFixed(1)}a`;
                resultValue.textContent = `(${(state.vectorA.x * state.scalar).toFixed(0)}, ${(state.vectorA.y * state.scalar).toFixed(0)})`;
                const magnitude = Math.abs(state.scalar) * Math.sqrt(state.vectorA.x**2 + state.vectorA.y**2);
                resultMagnitude.textContent = `|${state.scalar.toFixed(1)}a| = ${magnitude.toFixed(2)}`;
            } else if (state.mode === 'dot') {
                resultTitle.textContent = 'a â€¢ b';
                const dotProduct = state.vectorA.x * state.vectorB.x + state.vectorA.y * state.vectorB.y;
                resultValue.textContent = dotProduct.toFixed(1);
                resultMagnitude.textContent = '';
            }
            
            // Update theory content
            updateTheoryContent();
        }

        // Set the current mode
        function setMode(mode) {
            state.mode = mode;
            state.animProgress = 0;
            state.animating = false;
            clearInterval(animationInterval);
            updateUI();
            draw();
        }

        // Handle scalar slider change
        function handleScalarChange(e) {
            state.scalar = parseFloat(e.target.value);
            updateUI();
            draw();
        }

        // Start animation for vector addition
        function startAnimation() {
            if (state.mode !== 'addition' || state.animating) return;
            
            state.animating = true;
            state.animProgress = 0;
            
            animateBtn.innerHTML = '<i class="fas fa-pause"></i> Animating';
            animateBtn.disabled = true;
            
            animationInterval = setInterval(() => {
                state.animProgress += 0.02;
                if (state.animProgress >= 1) {
                    state.animating = false;
                    clearInterval(animationInterval);
                    animateBtn.innerHTML = '<i class="fas fa-play"></i> Animate';
                    animateBtn.disabled = false;
                }
                draw();
            }, 30);
        }

        // Reset vectors to initial state
        function resetVectors() {
            state.vectorA = { x: 150, y: 100 };
            state.vectorB = { x: 100, y: 150 };
            state.scalar = 1.5;
            state.animProgress = 0;
            state.animating = false;
            clearInterval(animationInterval);
            scalarSlider.value = state.scalar;
            
            animateBtn.innerHTML = '<i class="fas fa-play"></i> Animate';
            animateBtn.disabled = false;
            
            updateUI();
            draw();
        }

        // Show theory panel (for mobile)
        function showTheoryPanel() {
            theoryPanel.classList.add('active');
            overlay.classList.add('active');
        }

        // Hide theory panel (for mobile)
        function hideTheoryPanel() {
            theoryPanel.classList.remove('active');
            overlay.classList.remove('active');
        }

        // Update theory content based on current mode
        function updateTheoryContent() {
            const theoryData = {
                addition: {
                    title: "Vector Addition",
                    definition: "Vector addition combines two vectors by placing them tip-to-tail. The resultant vector extends from the tail of the first to the tip of the second.",
                    formula: "$$\\vec{a} + \\vec{b} = \\begin{pmatrix} a_x + b_x \\\\ a_y + b_y \\end{pmatrix}$$",
                    properties: [
                        "**Commutative**: $$\\vec{a} + \\vec{b} = \\vec{b} + \\vec{a}$$",
                        "**Associative**: $$(\\vec{a} + \\vec{b}) + \\vec{c} = \\vec{a} + (\\vec{b} + \\vec{c})$$",
                        "**Identity**: $$\\vec{a} + \\vec{0} = \\vec{a}$$",
                        "**Inverse**: $$\\vec{a} + (-\\vec{a}) = \\vec{0}$$"
                    ],
                    geometric: "The parallelogram law states that the sum of two vectors forms the diagonal of the parallelogram defined by those vectors. This geometric interpretation shows that vector addition is commutative.",
                    example: `For $$\\vec{a} = \\begin{pmatrix} ${state.vectorA.x.toFixed(0)} \\\\ ${state.vectorA.y.toFixed(0)} \\end{pmatrix}$$ and $$\\vec{b} = \\begin{pmatrix} ${state.vectorB.x.toFixed(0)} \\\\ ${state.vectorB.y.toFixed(0)} \\end{pmatrix}$$:\n\n$$\\vec{a} + \\vec{b} = \\begin{pmatrix} ${state.vectorA.x.toFixed(0)} + ${state.vectorB.x.toFixed(0)} \\\\ ${state.vectorA.y.toFixed(0)} + ${state.vectorB.y.toFixed(0)} \\end{pmatrix} = \\begin{pmatrix} ${(state.vectorA.x + state.vectorB.x).toFixed(0)} \\\\ ${(state.vectorA.y + state.vectorB.y).toFixed(0)} \\end{pmatrix}$$`,
                    insight: "Vectors represent displacements. Adding them is like taking multiple journeys in sequenceâ€”the result is your final position. This makes vector addition fundamental to physics, where it describes the net effect of multiple forces or movements."
                },
                scalar: {
                    title: "Scalar Multiplication",
                    definition: "Scalar multiplication scales a vector by a real number, changing its magnitude and possibly direction. If the scalar is negative, the direction is reversed.",
                    formula: "$$c\\vec{a} = \\begin{pmatrix} c \\cdot a_x \\\\ c \\cdot a_y \\end{pmatrix}$$",
                    properties: [
                        "**Distributive over vector addition**: $$c(\\vec{a} + \\vec{b}) = c\\vec{a} + c\\vec{b}$$",
                        "**Distributive over scalar addition**: $$(c + d)\\vec{a} = c\\vec{a} + d\\vec{a}$$",
                        "**Associative**: $$(cd)\\vec{a} = c(d\\vec{a})$$",
                        "**Identity**: $$1\\vec{a} = \\vec{a}$$"
                    ],
                    geometric: `When $$c > 1$$: vector stretches. When $$0 < c < 1$$: vector shrinks. When $$c < 0$$: vector flips direction. The direction is preserved for positive scalars.`,
                    example: `For $$c = ${state.scalar.toFixed(2)}$$ and $$\\vec{a} = \\begin{pmatrix} ${state.vectorA.x.toFixed(0)} \\\\ ${state.vectorA.y.toFixed(0)} \\end{pmatrix}$$:\n\n$$${state.scalar.toFixed(2)}\\vec{a} = ${state.scalar.toFixed(2)} \\cdot \\begin{pmatrix} ${state.vectorA.x.toFixed(0)} \\\\ ${state.vectorA.y.toFixed(0)} \\end{pmatrix} = \\begin{pmatrix} ${(state.vectorA.x * state.scalar).toFixed(0)} \\\\ ${(state.vectorA.y * state.scalar).toFixed(0)} \\end{pmatrix}$$`,
                    insight: "Scalar multiplication allows us to scale vectors without changing their direction (for positive scalars). This operation is fundamental in linear algebra and physics, where it represents concepts like velocity scaling or force amplification."
                },
                dot: {
                    title: "Dot Product (Inner Product)",
                    definition: "The dot product is a scalar value measuring how much two vectors align. It equals the product of their magnitudes and the cosine of the angle between them.",
                    formula: "$$\\vec{a} \\cdot \\vec{b} = a_x b_x + a_y b_y = |\\vec{a}||\\vec{b}|\\cos\\theta$$",
                    properties: [
                        "**Commutative**: $$\\vec{a} \\cdot \\vec{b} = \\vec{b} \\cdot \\vec{a}$$",
                        "**Distributive**: $$\\vec{a} \\cdot (\\vec{b} + \\vec{c}) = \\vec{a} \\cdot \\vec{b} + \\vec{a} \\cdot \\vec{c}$$",
                        "**Orthogonality**: $$\\vec{a} \\cdot \\vec{b} = 0 \\iff \\vec{a} \\perp \\vec{b}$$",
                        "**Relation to magnitude**: $$\\vec{a} \\cdot \\vec{a} = |\\vec{a}|^2$$"
                    ],
                    geometric: "The dot product represents the projection of one vector onto another, scaled by the magnitude of the second vector. It measures directional alignment and is maximal when vectors point in the same direction.",
                    example: (() => {
                        const dot = state.vectorA.x * state.vectorB.x + state.vectorA.y * state.vectorB.y;
                        const magA = Math.sqrt(state.vectorA.x ** 2 + state.vectorA.y ** 2);
                        const magB = Math.sqrt(state.vectorB.x ** 2 + state.vectorB.y ** 2);
                        const angle = Math.acos(dot / (magA * magB + 0.0001)) * (180 / Math.PI);
                        return `For $$\\vec{a} = \\begin{pmatrix} ${state.vectorA.x.toFixed(0)} \\\\ ${state.vectorA.y.toFixed(0)} \\end{pmatrix}$$ and $$\\vec{b} = \\begin{pmatrix} ${state.vectorB.x.toFixed(0)} \\\\ ${state.vectorB.y.toFixed(0)} \\end{pmatrix}$$:\n\n$$\\vec{a} \\cdot \\vec{b} = ${state.vectorA.x.toFixed(0)} \\cdot ${state.vectorB.x.toFixed(0)} + ${state.vectorA.y.toFixed(0)} \\cdot ${state.vectorB.y.toFixed(0)} = ${dot.toFixed(1)}$$\n\n$$|\\vec{a}| = \\sqrt{${state.vectorA.x.toFixed(0)}^2 + ${state.vectorA.y.toFixed(0)}^2} = ${magA.toFixed(1)}$$\n\n$$|\\vec{b}| = \\sqrt{${state.vectorB.x.toFixed(0)}^2 + ${state.vectorB.y.toFixed(0)}^2} = ${magB.toFixed(1)}$$\n\n$$\\theta = \\cos^{-1}\\left(\\frac{${dot.toFixed(1)}}{${magA.toFixed(1)} \\cdot ${magB.toFixed(1)}}\\right) = ${angle.toFixed(1)}Â°$$`;
                    })(),
                    insight: "The dot product tells you how much two vectors 'agree' in direction. When perpendicular, they don't agree at all (dot product = 0). This operation is fundamental in physics for calculating work and in computer graphics for lighting calculations."
                }
            };

            const currentTheory = theoryData[state.mode];
            
            let content = `
                <div class="theory-section">
                    <h3>${currentTheory.title}</h3>
                    <p>${currentTheory.definition}</p>
                </div>

                <div class="formula-box">
                    <h4>Mathematical Definition</h4>
                    <div>${currentTheory.formula}</div>
                </div>

                <div class="theory-section">
                    <h4>Algebraic Properties</h4>
                    <ul class="properties-list">
                        ${currentTheory.properties.map(prop => `
                            <li>${prop.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</li>
                        `).join('')}
                    </ul>
                </div>

                <div class="highlight-box">
                    <h4>Geometric Interpretation</h4>
                    <p>${currentTheory.geometric}</p>
                </div>

                <div class="example-box">
                    <h4>Current Calculation</h4>
                    <div>${currentTheory.example}</div>
                </div>

                <div class="insight-box">
                    <h4>ðŸ’¡ Physical Significance</h4>
                    <p>${currentTheory.insight}</p>
                </div>
            `;
            
            theoryContent.innerHTML = content;
            
            // Process MathJax rendering
            if (window.MathJax) {
                MathJax.typesetPromise([theoryContent]).catch(err => console.log('MathJax error:', err));
            }
        }

        // Drawing functions
        function drawGrid(ctx) {
            ctx.strokeStyle = 'rgba(100, 100, 120, 0.2)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= 800; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 600);
                ctx.stroke();
            }
            
            for (let y = 0; y <= 600; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(800, y);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(origin.x, 0);
            ctx.lineTo(origin.x, 600);
            ctx.moveTo(0, origin.y);
            ctx.lineTo(800, origin.y);
            ctx.stroke();
        }

        function drawVector(ctx, start, end, color, label, width = 3) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            if (len < 1) return;
            
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            
            const arrowSize = 12;
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(
                end.x - arrowSize * Math.cos(angle - Math.PI / 6),
                end.y - arrowSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                end.x - arrowSize * Math.cos(angle + Math.PI / 6),
                end.y - arrowSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = color;
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText(label, end.x + 10, end.y - 10);
        }

        function drawDashedLine(ctx, start, end, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function draw() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, 800, 600);
            
            if (state.showGrid) drawGrid(ctx);

            const endA = { x: origin.x + state.vectorA.x, y: origin.y - state.vectorA.y };
            const endB = { x: origin.x + state.vectorB.x, y: origin.y - state.vectorB.y };

            if (state.mode === 'addition') {
                const progress = state.animating ? state.animProgress : 1;
                
                drawVector(ctx, origin, endA, '#00ffff', 'a', 3);
                
                const currentB = {
                    x: origin.x + state.vectorB.x * progress,
                    y: origin.y - state.vectorB.y * progress
                };
                drawVector(ctx, origin, currentB, '#ff00ff', 'b', 3);
                
                if (progress > 0.3) {
                    const fadeIn = Math.min(1, (progress - 0.3) / 0.3);
                    drawDashedLine(ctx, endA, 
                        { x: endA.x + state.vectorB.x * fadeIn, y: endA.y - state.vectorB.y * fadeIn },
                        `rgba(255, 0, 255, ${fadeIn * 0.5})`);
                }
                
                if (progress > 0.6) {
                    const resultProgress = Math.min(1, (progress - 0.6) / 0.4);
                    const endSum = {
                        x: origin.x + (state.vectorA.x + state.vectorB.x) * resultProgress,
                        y: origin.y - (state.vectorA.y + state.vectorB.y) * resultProgress
                    };
                    drawVector(ctx, origin, endSum, '#ffff00', 'a + b', 4);
                }

                drawDashedLine(ctx, endA, { x: endA.x + state.vectorB.x, y: endA.y - state.vectorB.y }, 'rgba(255, 0, 255, 0.3)');
                drawDashedLine(ctx, endB, { x: endB.x + state.vectorA.x, y: endB.y - state.vectorA.y }, 'rgba(0, 255, 255, 0.3)');
                
            } else if (state.mode === 'scalar') {
                drawVector(ctx, origin, endA, '#00ffff', 'a', 3);
                
                const scaled = {
                    x: origin.x + state.vectorA.x * state.scalar,
                    y: origin.y - state.vectorA.y * state.scalar
                };
                drawVector(ctx, origin, scaled, '#ff6b00', `${state.scalar.toFixed(1)}a`, 4);
                
            } else if (state.mode === 'dot') {
                drawVector(ctx, origin, endA, '#00ffff', 'a', 3);
                drawVector(ctx, origin, endB, '#ff00ff', 'b', 3);
                
                const dotProduct = state.vectorA.x * state.vectorB.x + state.vectorA.y * state.vectorB.y;
                const magA = Math.sqrt(state.vectorA.x ** 2 + state.vectorA.y ** 2);
                const magB = Math.sqrt(state.vectorB.x ** 2 + state.vectorB.y ** 2);
                
                if (magA > 0) {
                    const projScalar = dotProduct / (magA * magA);
                    const proj = {
                        x: origin.x + state.vectorA.x * projScalar,
                        y: origin.y - state.vectorA.y * projScalar
                    };
                    
                    drawVector(ctx, origin, proj, '#00ff00', 'proj', 3);
                    drawDashedLine(ctx, proj, endB, 'rgba(0, 255, 0, 0.5)');
                    
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                    ctx.fillRect(proj.x - 3, proj.y - 3, 6, 6);
                }
                
                const angle = Math.acos(dotProduct / (magA * magB + 0.0001)) * (180 / Math.PI);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px sans-serif';
                ctx.fillText(`a Â· b = ${dotProduct.toFixed(1)}`, 20, 40);
                ctx.fillText(`Î¸ = ${angle.toFixed(1)}Â°`, 20, 65);
            }
        }

        // Mouse event handlers for dragging
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            checkDragStart(x, y);
        }

        function handleMouseMove(e) {
            if (!state.dragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            updateDraggedVector(x, y);
        }

        function handleMouseUp() {
            state.dragging = null;
            canvas.style.cursor = 'crosshair';
        }

        // Touch event handlers for mobile
        function handleTouchStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            checkDragStart(x, y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!state.dragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            updateDraggedVector(x, y);
        }

        // Check if drag started on a vector endpoint
        function checkDragStart(x, y) {
            const endA = { x: origin.x + state.vectorA.x, y: origin.y - state.vectorA.y };
            const endB = { x: origin.x + state.vectorB.x, y: origin.y - state.vectorB.y };
            
            // Check if click is near vector A endpoint
            if (Math.hypot(x - endA.x, y - endA.y) < 20) {
                state.dragging = 'A';
                canvas.style.cursor = 'grabbing';
            }
            // Check if click is near vector B endpoint
            else if (Math.hypot(x - endB.x, y - endB.y) < 20) {
                state.dragging = 'B';
                canvas.style.cursor = 'grabbing';
            }
        }

        // Update the dragged vector based on mouse position
        function updateDraggedVector(x, y) {
            const newVec = {
                x: x - origin.x,
                y: origin.y - y  // Invert y-axis for mathematical coordinates
            };
            
            if (state.dragging === 'A') {
                state.vectorA = newVec;
            } else if (state.dragging === 'B') {
                state.vectorB = newVec;
            }
            
            updateUI();
            draw();
        }

        // Initialize the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
